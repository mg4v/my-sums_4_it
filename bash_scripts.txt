++++++++++++++++++++++++++++++
++      BASH СКРИПТЫ        ++
++                          ++
++++++++++++++++++++++++++++++

# Вывести максимально допустимое количество аргументов передаваемых в команде:
getconf ARG_MAX

# Получить абсолютное имя текущей оболочки:
echo $SHELL
# или:
echo $0

# Определить, работающий процесс текущей оболочки:
echo $$

# Посмотреть список оболочек, доступных в системе:
cat /etc/shells

# временно переключиться на другую оболочку:
<имя_оболочки>

# изменение командной оболочки на постоянной основе:
chsh -s <путь_новой_оболочки>

# изменить оболочку, используемую по умолчанию, для другого пользователя:
chsh -s <путь_новой_оболочки> <имя_пользователя>

Файл скрипта может иметь любое имя, расширение ".sh" нужно только для удобства пользователя.
# Что-бы запускать скрипт из оболочки, необходимо сделать файл скрипта исполняемым:
chmod +x <скрипт.sh>

# Запуск скрипта из оболочки:
./<скрипт.sh>

-----------------
ОБЩЕЕ СОДЕРЖИМОЕ:
-----------------

Первая строка всегда шибанг:
#!/bin/bash

Строка комментария начинается с #

кобанды считываются по строчно, либо разделяются знаком ";", например:
```
<команда> ; <команда> ; <команда>
<команда>
<команда>
<команда>
```

-----------
ПЕРЕМЕННЫЕ:
-----------

# Обьявить переменную
имя_переменной
 
# Вызвать переменную:
$имя_переменной
 
# Присвоить значение переменной:
имя_переменной=значение_переменной
имя_переменной=5
имя_переменной="текст"
имя_переменной=$((a+b))
имя_переменной=`команда`
имя_переменной=$(команда)

# В условии, если переменная содержит пробелы и спецсимволы - заключается в кавычки.

-------------------------
ВЫВОД СООБЩЕНИЙ НА ЭКРАН:
-------------------------

echo "текст"

# Если хотим указать в выводе на экран название переменной, а не ее значение"
echo "текст \$переменная"

# Перевод строки:
echo -e "текст\n"


-------------------------------------
УПРАВЛЯЮЩАЯ КОНСТРУКЦИЯ IF-THEN-ELSE:
-------------------------------------

Если условие - истина (возвращает 0) значит оно исполняется, иначе - нет.

```
if условие ; then
  действие
elif условие ; then
  действие
else
  действие
fi
```

# В качестве условия могут быть:
 - переменная;
 - выражение;
 - результат выполнения команды - команду не нужно заключать в скобки или кавычки.
 
 Можно указывать несколько условий через &&
----------------
СРАВНЕНИЕ ЧИСЕЛ:
----------------

n1 -eq n2Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2.
n1 -gt n2Возвращает истинное значение, если n1 больше n2.
n1 -le n2Возвращает истинное значение, если n1меньше или равно n2.
n1 -lt n2Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2Возвращает истинное значение, если n1не равно n2.

# В условии задается как:
if [ $val1 -gt 5 ]

----------------
СРАВНЕНИЕ СТРОК:
----------------

str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2 Возвращает истину, если строки не идентичны.
str1 < str2 Возвращает истину, если str1 меньше, чем str2.
str1 > str2 Возвращает истину, если str1 больше, чем str2.
-n str1 Возвращает истину, если длина str1 больше нуля.
-z str1 Возвращает истину, если длина str 1равна нулю.

# В условии задается как:
if [$user = $USER]

# знаки >< экранируются \:
if [ $val1 \> $val2 ]

#  В командах сравнения прописные буквы меньше строчных.
## Сравнение строк здесь выполняется путём сравнения ASCII-кодов символов,
## порядок сортировки, таким образом, зависит от кодов символов.

# Команда sort, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.

----------------
ПРОВЕРКИ ФАЙЛОВ:
----------------

-d file Проверяет, существует ли файл, и является ли он директорией.
-e file Проверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r file Проверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w file Проверяет, существует ли файл, и доступен ли он для записи.
-x file Проверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2 Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G file Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

---------
ЦИКЛ FOR:
---------

```
for var in list
do
  действие
done
```

# вместо list - указывается переменная, выражение, результат команды или файл.
# for для списка:
for var in word word word

# Перебор сложных значений:
for var in first "the second" "the third" "I’ll do it"

# Инициализация цикла списком, полученным из результатов работы команды:
for var in $(cat $file)

Разделители полей:
------------------

По умолчанию оболочка bash считает разделителями полей следующие символы:
 - Пробел
 - Знак табуляции
 - Знак перевода строки
 
Эти разделители задаются в переменной: IFS (Internal Field Separator).
# Указать в скрипте в качетсве разделителя только перевод строки:
IFS=$'\n'

# Указать в скрипте в качетсве разделителя двоеточие:
IFS=:

Циклы for в стиле C:
--------------------

```
for (( i=1; i <= 10; i++ ))
```

-----------
ЦИКЛ WHILE:
-----------

```
while команда проверки условия
do
  другие команды
done
```

Команда break:
--------------
Эта команда позволяет прервать выполнение цикла. Её можно использовать и для циклов for, и для циклов while:
Цикл будет прерван после соблюдения условия.

Команда continue:
-----------------

Когда условие внутри цикла выполняется, то есть, когда $var1 больше 5 и меньше 10, оболочка исполняет команду continue.
Это приводит к пропуску оставшихся в теле цикла команд и переходу к следующей итерации.

Например:

```
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
  if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
    then
      continue
  fi
  echo "Iteration number: $var1"
done
```
Последовательно выведет на экран все значения, пропустив с 6 по 9.

Обработка вывода, выполняемого в цикле:
---------------------------------------

Данные, выводимые в цикле, можно обработать, либо перенаправив вывод, либо передав их в конвейер.
Делается это с помощью добавления команд обработки вывода после инструкции done.

Например, вместо того, чтобы показывать на экране то,
  что выводится в цикле, можно записать всё это в файл или передать ещё куда-нибудь:

```
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > myfile.txt
echo "finished."
```

Оболочка создаст файл myfile.txt и перенаправит в этот файл вывод конструкции for.

-----------------------------------
ПАРАМЕТРЫ И КЛЮЧИ КОМАНДНОЙ СТРОКИ:
-----------------------------------

