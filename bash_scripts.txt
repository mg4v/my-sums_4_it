++++++++++++++++++++++++++++++
++      BASH СКРИПТЫ        ++
++                          ++
++++++++++++++++++++++++++++++

# Вывести максимально допустимое количество аргументов передаваемых в команде:
getconf ARG_MAX

# Получить абсолютное имя текущей оболочки:
echo $SHELL
# или:
echo $0

# Определить, работающий процесс текущей оболочки:
echo $$

# Посмотреть список оболочек, доступных в системе:
cat /etc/shells

# временно переключиться на другую оболочку:
<имя_оболочки>

# изменение командной оболочки на постоянной основе:
chsh -s <путь_новой_оболочки>

# изменить оболочку, используемую по умолчанию, для другого пользователя:
chsh -s <путь_новой_оболочки> <имя_пользователя>

Файл скрипта может иметь любое имя, расширение ".sh" нужно только для удобства пользователя.
# Что-бы запускать скрипт из оболочки, необходимо сделать файл скрипта исполняемым:
chmod +x <скрипт.sh>

# Запуск скрипта из оболочки:
./<скрипт.sh>

-----------------
ОБЩЕЕ СОДЕРЖИМОЕ:
-----------------

Первая строка всегда шибанг:
#!/bin/bash

Строка комментария начинается с #

кобанды считываются по строчно, либо разделяются знаком ";", например:
```
<команда> ; <команда> ; <команда>
<команда>
<команда>
<команда>
```

-----------
ПЕРЕМЕННЫЕ:
-----------

# Обьявить переменную
имя_переменной
 
# Вызвать переменную:
$имя_переменной
 
# Присвоить значение переменной:
имя_переменной=значение_переменной
имя_переменной=5
имя_переменной="текст"
имя_переменной=$((a+b))
имя_переменной=`команда`
имя_переменной=$(команда)

# В условии, если переменная содержит пробелы и спецсимволы - заключается в кавычки.

-------------------------
ВЫВОД СООБЩЕНИЙ НА ЭКРАН:
-------------------------

echo "текст"

# Если хотим указать в выводе на экран название переменной, а не ее значение"
echo "текст \$переменная"

# Перевод строки:
echo -e "текст\n"


-------------------------------------
УПРАВЛЯЮЩАЯ КОНСТРУКЦИЯ IF-THEN-ELSE:
-------------------------------------

Если условие - истина (возвращает 0) значит оно исполняется, иначе - нет.

```
if условие ; then
  действие
elif условие ; then
  действие
else
  действие
fi
```

# В качестве условия могут быть:
 - переменная;
 - выражение;
 - результат выполнения команды - команду не нужно заключать в скобки или кавычки.
 
----------------
СРАВНЕНИЕ ЧИСЕЛ:
----------------

n1 -eq n2Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2.
n1 -gt n2Возвращает истинное значение, если n1 больше n2.
n1 -le n2Возвращает истинное значение, если n1меньше или равно n2.
n1 -lt n2Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2Возвращает истинное значение, если n1не равно n2.

# В условии задается как:
if [ $val1 -gt 5 ]

----------------
СРАВНЕНИЕ СТРОК:
----------------

str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2Возвращает истину, если строки не идентичны.
str1 < str2Возвращает истину, если str1меньше, чем str2.
str1 > str2 Возвращает истину, если str1больше, чем str2.
-n str1 Возвращает истину, если длина str1больше нуля.
-z str1Возвращает истину, если длина str1равна нулю.

# В условии задается как:
if [$user = $USER]

# знаки >< экранируются \:
if [ $val1 \> $val2 ]

#  В командах сравнения прописные буквы меньше строчных.
## Сравнение строк здесь выполняется путём сравнения ASCII-кодов символов,
## порядок сортировки, таким образом, зависит от кодов символов.

# Команда sort, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.

----------------
ПРОВЕРКИ ФАЙЛОВ:
----------------

-d fileПроверяет, существует ли файл, и является ли он директорией.
-e fileПроверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r fileПроверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w fileПроверяет, существует ли файл, и доступен ли он для записи.
-x fileПроверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G fileПроверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.








