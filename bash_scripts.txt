++++++++++++++++++++++++++++++
++      BASH СКРИПТЫ        ++
++                          ++
++++++++++++++++++++++++++++++

# Вывести максимально допустимое количество аргументов передаваемых в команде:
getconf ARG_MAX

# Получить абсолютное имя текущей оболочки:
echo $SHELL
# или:
echo $0

# Определить, работающий процесс текущей оболочки:
echo $$

# Посмотреть список оболочек, доступных в системе:
cat /etc/shells

# временно переключиться на другую оболочку:
<имя_оболочки>

# изменение командной оболочки на постоянной основе:
chsh -s <путь_новой_оболочки>

# изменить оболочку, используемую по умолчанию, для другого пользователя:
chsh -s <путь_новой_оболочки> <имя_пользователя>

Файл скрипта может иметь любое имя, расширение ".sh" нужно только для удобства пользователя.
# Что-бы запускать скрипт из оболочки, необходимо сделать файл скрипта исполняемым:
chmod +x <скрипт.sh>

# Запуск скрипта из оболочки:
./<скрипт.sh>


# переменная $# содержит количество параметров, переданных сценарию при вызове

-----------------
ОБЩЕЕ СОДЕРЖИМОЕ:
-----------------

Первая строка всегда шибанг:
#!/bin/bash

Строка комментария начинается с #

кобанды считываются по строчно, либо разделяются знаком ";", например:
```
<команда> ; <команда> ; <команда>
<команда>
<команда>
<команда>
```

-----------
ПЕРЕМЕННЫЕ:
-----------

# Обьявить переменную
имя_переменной
 
# Вызвать переменную:
$имя_переменной
 
# Присвоить значение переменной:
имя_переменной=значение_переменной
имя_переменной=5
имя_переменной="текст"

Выражение:
имя_переменной=$((a+b))
или:
имя_переменной=$[ a+b ]

Команда:
имя_переменной=`команда`
или:
имя_переменной=$(команда)

# В условии, если переменная содержит пробелы и спецсимволы - заключается в кавычки.

-------------------------
ВЫВОД СООБЩЕНИЙ НА ЭКРАН:
-------------------------

echo "текст"

# Если хотим указать в выводе на экран название переменной, а не ее значение"
echo "текст \$переменная"

# Перевод строки:
echo -e "текст\n"


-------------------------------------
УПРАВЛЯЮЩАЯ КОНСТРУКЦИЯ IF-THEN-ELSE:
-------------------------------------

Если условие - истина (возвращает 0) значит оно исполняется, иначе - нет.

```
if условие ; then
  действие
elif условие ; then
  действие
else
  действие
fi
```

# В качестве условия могут быть:
 - переменная;
 - выражение;
 - результат выполнения команды - команду не нужно заключать в скобки или кавычки.
 
 Можно указывать несколько условий через &&
----------------
СРАВНЕНИЕ ЧИСЕЛ:
----------------

n1 -eq n2Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2.
n1 -gt n2Возвращает истинное значение, если n1 больше n2.
n1 -le n2Возвращает истинное значение, если n1меньше или равно n2.
n1 -lt n2Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2Возвращает истинное значение, если n1не равно n2.

# В условии задается как:
if [ $val1 -gt 5 ]

----------------
СРАВНЕНИЕ СТРОК:
----------------

str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2 Возвращает истину, если строки не идентичны.
str1 < str2 Возвращает истину, если str1 меньше, чем str2.
str1 > str2 Возвращает истину, если str1 больше, чем str2.
-n str1 Возвращает истину, если длина str1 больше нуля.
-z str1 Возвращает истину, если длина str 1равна нулю.

# В условии задается как:
if [$user = $USER]

# знаки >< экранируются \:
if [ $val1 \> $val2 ]

#  В командах сравнения прописные буквы меньше строчных.
## Сравнение строк здесь выполняется путём сравнения ASCII-кодов символов,
## порядок сортировки, таким образом, зависит от кодов символов.

# Команда sort, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.

----------------
ПРОВЕРКИ ФАЙЛОВ:
----------------

-d file Проверяет, существует ли файл, и является ли он директорией.
-e file Проверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r file Проверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w file Проверяет, существует ли файл, и доступен ли он для записи.
-x file Проверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2 Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G file Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

---------
ЦИКЛ FOR:
---------

```
for var in list
do
  действие
done
```

# вместо list - указывается переменная, выражение, результат команды или файл.
# for для списка:
for var in word word word

# Перебор сложных значений:
for var in first "the second" "the third" "I’ll do it"

# Инициализация цикла списком, полученным из результатов работы команды:
for var in $(cat $file)

Разделители полей:
------------------

По умолчанию оболочка bash считает разделителями полей следующие символы:
 - Пробел
 - Знак табуляции
 - Знак перевода строки
 
Эти разделители задаются в переменной: IFS (Internal Field Separator).
# Указать в скрипте в качетсве разделителя только перевод строки:
IFS=$'\n'

# Указать в скрипте в качетсве разделителя двоеточие:
IFS=:

Циклы for в стиле C:
--------------------

```
for (( i=1; i <= 10; i++ ))
```

-----------
ЦИКЛ WHILE:
-----------

```
while команда проверки условия
do
  другие команды
done
```

Команда break:
--------------
Эта команда позволяет прервать выполнение цикла. Её можно использовать и для циклов for, и для циклов while:
Цикл будет прерван после соблюдения условия.

Команда continue:
-----------------

Когда условие внутри цикла выполняется, то есть, когда $var1 больше 5 и меньше 10, оболочка исполняет команду continue.
Это приводит к пропуску оставшихся в теле цикла команд и переходу к следующей итерации.

Например:

```
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
  if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
    then
      continue
  fi
  echo "Iteration number: $var1"
done
```
Последовательно выведет на экран все значения, пропустив с 6 по 9.

Обработка вывода, выполняемого в цикле:
---------------------------------------

Данные, выводимые в цикле, можно обработать, либо перенаправив вывод, либо передав их в конвейер.
Делается это с помощью добавления команд обработки вывода после инструкции done.

Например, вместо того, чтобы показывать на экране то,
  что выводится в цикле, можно записать всё это в файл или передать ещё куда-нибудь:

```
done > myfile.txt
```

Оболочка создаст файл myfile.txt и перенаправит в этот файл вывод конструкции for.

-----------------------------------
ПАРАМЕТРЫ И КЛЮЧИ КОМАНДНОЙ СТРОКИ:
-----------------------------------

Чтение параметров командной строки:
-----------------------------------

Оболочка bash назначает специальным переменным, называемым позиционными параметрами,
введённые при вызове скрипта параметры командной строки:

  $0 — имя скрипта.
  $1 — первый параметр.
  $2 — второй параметр — и так далее, вплоть до переменной $9, в которую попадает девятый параметр.
  ${10} - Если скрипту надо больше девяти параметров.
! Обратите внимание на то, что параметры командной строки разделяются пробелами.

Проверка параметров:
--------------------

Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие,
возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове.
Например, это можно организовать так:

```
if [ -n "$1" ]
```

Подсчёт параметров:
-------------------

Переменная $# содержит количество параметров, переданных сценарию при вызове.
${!#} - выводит значение последнего параметра.

Захват всех параметров командной строки:
----------------------------------------

Для этого можно воспользоваться переменными $* и $@.
Обе они содержат все параметры командной строки, что делает возможным доступ к тому,
  что передано сценарию, без использования позиционных параметров:
  
  - $* содержит все параметры, введённые в командной строке, в виде единого «слова».
  - $@ параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.

Команда shift:
--------------
shift - сдвигает значения позиционных параметров.

Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево.
Например, значение переменной $3 становится значением переменной $2, значение $2 переходит в $1, а то, что было до этого в $1, теряется. Обратите внимание на то, что при этом значение переменной $0, содержащей имя скрипта, не меняется.

Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной $3 становится значением переменной $2, значение $2 переходит в $1, а то, что было до этого в $1, теряется. Обратите внимание на то, что при этом значение переменной $0, содержащей имя скрипта, не меняется.
Используя команду shift, помните о том, что при каждом её вызове значение переменной $1 безвозвратно теряется.

Команда case:
-------------

case - сверяет переданный ей ключ со списком обрабатываемых скриптом ключей.
Если переданное значение нашлось в этом списке, выполняется соответствующая ветвь кода.
Если при вызове скрипта будет использован любой ключ, обработка которого не предусмотрена, будет исполнена ветвь «*».

```
  case "$параметр_командной_строки" in
    -<значение_параметра>) <действие_если_найден> ;;
    -<значение_параметра>) <действие_если_найден> ;;
    -<значение_параметра>) <действие_если_найден> ;;
    *) <действие_для_прочих_параметров> ;;
  esac
```

Как различать ключи и параметры:
--------------------------------
-- Оболочка использует её для указания позиции, на которой заканчивается список ключей.
После того, как скрипт обнаружит признак окончания ключей, то,
что осталось, можно, не опасаясь ошибок, обрабатывать как параметры, а не как ключи.

Пример запуска скрипта с передачей ключей и параметров:
./скрипт.sh -ключ1 -ключ2 -ключ3 -- $1 $2 ${10}


сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.

Использование стандартных ключей:
---------------------------------

При написании bash-скриптов вы можете выбирать любые буквы для ключей командной строки и произвольно задавать реакцию скрипта на эти ключи. Однако, в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:

-a Вывести все объекты.
-c Произвести подсчёт.
-d Указать директорию.
-e Развернуть объект.
-f Указать файл, из которого нужно прочитать данные.
-h Вывести справку по команде.
-i Игнорировать регистр символов.
-l Выполнить полноформатный вывод данных.
-n Использовать неинтерактивный (пакетный) режим.
-o Позволяет указать файл, в который нужно перенаправить вывод.
-q Выполнить скрипт в quiet-режиме.
-r Обрабатывать папки и файлы рекурсивно.
-s Выполнить скрипт в silent-режиме.
-v Выполнить многословный вывод.
-x Исключить объект.
-y Ответить «yes» на все вопросы.

Получение данных от пользователя:
---------------------------------

# Эта команда позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры),
либо используя другие дескрипторы файлов. После получения данных, эта команда помещает их в переменную:

read <имя_переменной>

# При вызове read можно указывать и несколько переменных:
read -p <имя_переменной1> <имя_переменной2>

# Продолжить выполнение скрипта через указанное время не зависимо от того, ввел что-либо пользователь или нет:
read -t <время_ожидания_в_секундах> <имя_переменной1>
