
  __  __        _____  ____  _
 |  \/  |      / ____|/ __ \| |
 | \  / |_   _| (___ | |  | | |
 | |\/| | | | |\___ \| |  | | |
 | |  | | |_| |____) | |__| | |____
 |_|  |_|\__, |_____/ \___\_\______|
          __/ |
         |___/

-------------------
Установить - MySQL:
https://downloads.mysql.com/archives/installer/

===================
-------------------
РАБОТА В CLI MYSQL:
-------------------
===================

+---------+--------------------------+-----------+----------------------------+
| КОМАНДА | ОПЦИИ                    | ОКОНЧАНИЕ | ОПИСАНИЕ                   |
+---------+--------------------------+-----------+----------------------------+
| show    | databases                |     ;     | Показать доступные БД      |
|         +--------------------------+           +----------------------------+
|         | tables                   |           | Показать доступные таблицы |
|         +--------------------------+           +----------------------------+
|         | columns from Имя_Таблицы |           | Показать колонки в таблице |
+---------+--------------------------+           +----------------------------+
| use     | Имя_Базы                 |           | Открыть БД                 |
+---------+--------------------------+-----------+----------------------------+

# Узнать где хранятся файлы БД:
SELECT @@datadir;

# Посмотреть взаимосвязь таблиц на диаграмме:
[MENU]-->[Database]-->[Reverse Engineer..]

=========================
-------------------------
СИНТАКСИС ЗАПРОСОВ MYSQL:
-------------------------
=========================

-------------------
Создать БД (схему):
---------------------

CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_option] ...

create_option: [DEFAULT] {
    CHARACTER SET [=] charset_name
  | COLLATE [=] collation_name
  | ENCRYPTION [=] {'Y' | 'N'}
}

## Пример:
CREATE SCHEMA `shop` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;

----------------
Создать таблицу:
----------------

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    (create_definition,...)
    [table_options]
    [partition_options]

## Пример:
CREATE TABLE `shop`.`category` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(128) NULL,
  `discount` TINYINT(3) NOT NULL,
  `alias_name` VARCHAR(128) NULL,
  PRIMARY KEY (`id`),
  UNIQUE INDEX `id_UNIQUE` (`id` ASC) VISIBLE,
  UNIQUE INDEX `alias_name_UNIQUE` (`alias_name` ASC) VISIBLE);

+------------+------------------+-------------+------------+-----------------------------------+
|     ТИП    |     НАЗВАНИЕ     |   МИНИМУМ   |  МАКСИМУМ  | КОММЕНТАРИИ                       |
|            |                  |    ЗНАКОВ   |   ЗНАКОВ   |                                   |
+------------+------------------+-------------+------------+-----------------------------------+
| ЧИСЛО      | INT              | -2147483648 | 2147483647 |                                   |
|            +------------------+-------------+------------+-----------------------------------+
|            | TINYINT          | -128        | 127        |                                   |
|            +------------------+-------------+------------+-----------------------------------+
|            | DECIMAL('X','Y') |      -      |      -     | Хранит точные числовые            |
|            |                  |             |            | значения данных,                  |
|            |                  |             |            | со знаками после запятой.         |
|            |                  |             |            | Подходит для хранения цен.        |
|            |                  |             |            | Где:                              |
|            |                  |             |            |     - X = всего разрядов;         |
|            |                  |             |            |     - Y = из них, после запятой.  |
|            |                  |             |            |                                   |
|            |                  |             |            | НАПРИМЕР: DECIMAL (5,2)           |
|            |                  |             |            | сможет хранить: -999,99 .. 999,99 |
+------------+------------------+-------------+------------+-----------------------------------+
| СТРОКА     | VARCHAR          | 0           | 65535      | Переменная длина,                 |
|            |                  |             |            | в пределах, заданных              |
|            |                  |             |            | при создании строки               |
|            +------------------+-------------+------------+-----------------------------------+
|            | CHAR             | 0           | 255        | Фиксированная длина,              |
|            |                  |             |            | задается при создании             |
|            |                  |             |            | строки                            |
+------------+------------------+-------------+------------+-----------------------------------+
| ДАТА/ВРЕМЯ | DATATIME         |      -      |      -     | Хранит время и дату в формате:    |
|            |                  |             |            | 'ГГГГ-ММ-ДД чч:мм:cc'             |
+------------+------------------+-------------+------------+-----------------------------------+

---------------------------
Добавить столбец в таблицу:
---------------------------
ALTER TABLE `shop`.`category`
ADD COLUMN `alias_name` VARCHAR(128) NULL AFTER `discount`;

--------------------------
Изменить свойства столбца:
--------------------------
ALTER TABLE `shop`.`category` 
CHANGE COLUMN `id` `id` INT NOT NULL AUTO_INCREMENT ,
ADD PRIMARY KEY (`id`);
;

----------------------------------
Посмотреть все содержимое таблицы:
----------------------------------
SELECT * FROM `Имя_Схемы`.`Имя_Таблицы`;

## Пример:
SELECT * FROM shop.category;

----------------
Удалить таблицу:
----------------
DROP TABLE `Имя_Схемы`.`Имя_Таблицы`;

## Пример:
DROP TABLE `shop`.`category`

--------------
Удалить схему:
--------------
DROP DATABASE `Имя_Схемы`;

## Пример:
DROP DATABASE `shop`

-------------------------------
Внести данные в строку таблицы:
-------------------------------
INSERT INTO  `Имя_Схемы`.`Имя_Таблицы` (`Столбец_1`, `Столбец_N`) VALUES ('Значение_1', 'Значение_N');

## Пример:
INSERT INTO `shop`.`category` (`name`, `discount`) VALUES ('Мужская обувь', '15');

!!! Если в значении строки используются командные спецсимволы (такие как "'") - экранируем их символом "\" !!!

---------------
ВЫБОРКА ДАННЫХ:
---------------
SELECT `Что_Вывести_(или_*)` FROM `Откуда_Или_Имя_Схемы.Имя_Таблицы` WHERE`Условия` `Ограничения`;

# Для вывода только уникальных значений указанных в части SELECT столбцов, указываем перед ними
    функцию DESTINCT(), например:
SELECT DISTINCT discount FROM category;

# Условия WHERE:
+-----------+----------------------+-----------------------------------------+------------------------------------+
| ОТРИЦАНИЕ | ЦЕЛЬ                 | УСЛОВИЕ                                 | ДОПОЛНИТЕЛЬНОЕ УСЛОВИЕ             |
+-----------+----------------------+-----------------------------------------+------------------------------------+
| NOT()     | 'Строка_или_выборка' | Знаки сравнения:                        | УСЛОВИЕ "И":                       |
|           |                      | ****************                        | ************                       |
|           |                      | =          : Равно;                     | 'Условие_1' AND 'Условие_2'        |
|           |                      | != или <>  : Неравно;                   |                                    |
|           |                      | >=         : Больше или равно;          | УСЛОВИЕ "ИЛИ":                     |
|           |                      | >          : Больше;                    | **************                     |
|           |                      |                                         | 'Условие_1' OR 'Условие_2'         |
|           |                      | <=         : Меньше или равно;          |                                    |
|           |                      | <          : Меньше.                    | УСЛОВИЕ "СОДЕРЖИТ"                 |
|           |                      +-----------------------------------------+ (равносильно AND/OR):              |
|           |                      | Условие равенства NULL:                 | *********************              |
|           |                      | ***********************                 | IN ('Значение_1', 'Значение_N')    |
|           |                      |                                         |                                    |
|           |                      | IS NULL     : Равно пустому значению;   |                                    |
|           |                      | IS NOT NULL ; Неравно пустому значению. |                                    |
+-----------+----------------------+-----------------------------------------+------------------------------------+

# Группировка, сортировка, ограничение:
+-------------------------------+-------------------------------------+
|            ФУНКЦИЯ            |               ОПИСАНИЕ              |
+-------------------------------+-------------------------------------+
| ORDER BY                      | Сортировка                          |
|     'Имя Столбца'             | по значениям                        |
|     'Порядок Сортировки'      | указанного столбца                  |
|                               |                                     |
| Порядок сортировки:           | Тип сортировки ASC                  |
| *******************           | выбирается по умолчанию,            |
|     - ASC   : по возрастанию; | поэтому его можно не указывать      |
|     - DESC  : по убыванию.    |                                     |
+-------------------------------+-------------------------------------+
| GROUP BY 'Имя Столбца'        | Группировать (схлопывать)           |
|                               | результаты по строкам с             |
|                               | одинаковым значением                |
|                               | указанного столбца                  |
+-------------------------------+-------------------------------------+
| LIMIT 'Количество Строк'      | Вывести только указанное количество |
|                               | первых строк                        |
+-------------------------------+-------------------------------------+

-----------------------------------------------
Обновить данные (изменить) в конкретной ячейке:
-----------------------------------------------
UPDATE `Имя_Схемы`.`Имя_Таблицы` SET `Столбец` = 'Значение' WHERE ('Условие');

--------------------------
Удалить строку из таблицы:
--------------------------
DELETE FROM `Имя_Схемы`.`Имя_Таблицы` WHERE ('Условие');

------------------------
Создание внешних ключей:
------------------------
# При создании таблицы, в последней строке команды создания указываем:
FOREIGN KEY (`Столбец`) REFERENCES `Имя_Схемы`.`Целевая_Таблица` (`Целевой_Столбец`)

# Если после создания таблицы - можно дополнительно создать правило связи:
!!! Благодаря созданному правилу
    СУБД будет следить за согласованностью данных в связываемых таблицах !!!

ALTER TABLE `Имя_Схемы`.`Имя_Таблицы`
ADD INDEX `fk_Имя_Правила_idx` (`Исходный_Столбец` ASC) VISIBLE;
;
ALTER TABLE `Имя_Схемы`.`Имя_Таблицы`
ADD CONSTRAINT `fk_Имя_Правила`
  FOREIGN KEY (`Исходный_Столбец`)
  REFERENCES `Имя_Схемы`.`Целевая_Таблица` (`Целевой_Столбец`)
  ON DELETE CASCADE
  ON UPDATE NO ACTION;

# где - CASCADE - будет отслеживать изменения в целевой таблице на случай удаления данных,
    на которые ссылается внешний ключ.

!!! ПРИ ОБЬЕДИНЕНИИ ТАБЛИЦ (ВНУТРЕННЕМ ИЛИ ВНЕШНЕМ)
    В КАЧЕСТВЕ ТОЧЕК (УСЛОВИЙ) ПЕРЕСЕЧЕНИЙ ИСПОЛЬЗУЮТ СВЯЗИ МЕЖДУ ТАБЛИЦАМИ
    НАСТРОЕННЫЕ С ПОМОЩЬЮ ВНЕШНИХ КЛЮЧЕЙ (ПО ОТНОШЕНИЮ К ПЕРВИЧНЫМ КЛЮЧАМ
    ЦЕЛЕВЫХ ТАБЛИЦ) !!!

-------------------------------------------
ВНУТРЕННЕЕ ОБЪЕДИНЕНИЕ ТАБЛИЦ (INNER JOIN):
-------------------------------------------
[ [ AB ] ]

# Пусть 'Таблица_1.Столбец_B' содержит FOREIGN_KEY до 'Таблица_N.Столбец_A',
    тогда:

SELECT 'Таблица_1.Столбец_A', 'Таблица_2.Столбец_B'
  FROM 'Таблица_1'
  INNER JOIN 'Таблица_N' ON 'Таблица_N.Столбец_A' = 'Таблица_1.Столбец_B';

# ПРИМЕР:
SELECT product.id, brand.name, product_type.name, category.name, price
  FROM product
  INNER JOIN brand on brand.id = product.brand_id
  INNER JOIN product_type ON product_type.id = product.product_type_id
  INNER JOIN category ON category.id = product.category_id ORDER BY product.id;

!!! ЕСЛИ, ПРИ ОБЪЕДИНЕНИИ ТАБЛИЦ, ТРЕБУЕТСЯ ВЫВЕСТИ ЗНАЧЕНИЯ ВСЕХ СТОЛБЦОВ КОНКРЕТНОЙ ТАБЛИЦЫ,
    МОЖНО В ЧАСТИ SELECT УКАЗАТЬ МАСКУ: 'Таблица_1.*' !!!

--------------------------------------
ЛЕВОЕ ВНЕШНЕЕ ОБЪЕДИНЕНИЕ (LEFT JOIN):
--------------------------------------
[ A [AB] ]

SELECT * FROM 'Левая таблица'
    LEFT JOIN 'Правая таблица'
        ON 'Правая таблица.Столбец_B' = 'Левая таблица.Столбец_A';


---------------------------------------
ПРАВОЕ ВНЕШНЕЕ ОБЪЕДИНЕНИЕ (RIGHT JOIN):
---------------------------------------
[ [AB] B ]

SELECT * FROM 'Левая таблица'
    RIGHT JOIN 'Правая таблица'
        ON 'Левая таблица.Столбец_B' = 'Правая таблица.Столбец_A';
Базовый вариант запроса выглядит следующим образом:
SELECT * FROM 'Левая таблица' RIGHT JOIN 'Правая таблица' ON 'Условие объединения';

-------------------------------------------
ПОЛНОЕ ВНЕШНЕЕ ОБЪЕДИНЕНИЕ (FULL OUTER JOIN):
-------------------------------------------
[ A [AB] B ]
SELECT * FROM 'Левая таблица' FULL OUTER JOIN 'Правая таблица' ON 'Условие объединения';

!!! В MySQL - данный тип объединения - НЕ ИСПОЛЬЗУЕТСЯ !!!
Помочь с полным объединением таблиц в MeSQL может запрос "UNION"

-------------------------------
ОБЪЕДИНЕНИЕ ДАННЫХ ЧЕРЕЗ UNION:
-------------------------------

'SELECT_1'
UNION
'SELECT_2'

# Например:
SELECT * FROM `order`
	LEFT JOIN order_products ON order_products.order_id = `order`.id
    LEFT JOIN product ON order_products.product_id = product.id

UNION

SELECT * FROM `order`
	INNER JOIN order_products ON order_products.order_id = `order`.id
    RIGHT JOIN product ON order_products.product_id = product.id
    WHERE `order`.id IS NULL;