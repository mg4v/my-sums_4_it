-------------
Установка Git
-------------
** В Debian:
#	apt install git

** В Redhat
#	yum install git
	
** Вывести номер установленной версии:	
$	git --version

-------------
Настройка Git
-------------

Общие параметры git хранятся в файле ".gitconfig"

$	git config
		--global		# Глобальная пользовательская настройка
			user.name "[name]"				# задать имя пользователя
			user.email "[email address]"	# -//- почтовый адрес -//-
			color.ui auto					# -//- автоматическую подсветку синтаксиса
			core.editor "[program]"			# -//- редактор текста по умолчанию (vi, vim, nano, mcedit, emacs и.т.д.) 
		--list			# вывести список настроек Git
		# или -l

--------------------
Создание репозитория
--------------------

** Cоздать локальный репозиторий в текущей папке:
$	git init

** Cоздать связь между локальным и удаленным репозиториями:
		(выполнять из папки локального репозитория)
$	git remote add <https://ssh_link_remote-repo> <local_name_repo_при-необходимости>		# по умолчанию присваивается имя - "origin"

** Полностью склонировать удаленный репозиторий в локальную папку:
		(При этом сохраняется связь между локальным (клоном) и удаленным репозиторием)
$	git clone <https://link_remote-repo>		# или ssh ссылка, требует внесение публичного ssh ключа в допущенные для подключения к аккаунту

** Посмотреть с какими удаленными репозиториями связан локальный репозиторий:
$	git remote -v

** Сменить ссылку на удаленный репозиторий (например сменить протокол https на ssh, или сослаться на другой репозиторий):
$	git remote -set-url <alias_repo> <link_remote-repo>

--------------------------------------
Синхронизация с удаленным репозиторием
--------------------------------------
** Подгрузить обновления из репозитория (обновляет список доступных для загрузки веток)
$	git fetch

** Скачать последние обновления ветки
$	git pull

** Загрузить в репозиторий локальные изменения
$	git push
		 origin		# не обязательный парамерт - ссылается на удаленный репозиторий (<alias_repo>)
		 -u <alias_repo><branch>
			# создать в удаленном репозитории новую ветку и загрузить в нее локальные изменения (или --set-upstream)
		 --delete <alias_repo> <branch>	# зафиксировать удаление указанной ветки из удаленного репозитория (после удаления из локального)
		 --force	# принудительно перезаписать историю (после выполнения git rebase в локальном репозитории)
		 --tags - загрузка тегов в удаленный репозиторий (после пуша изменений)
		 --delete <alias_repo> <tag>	# удаление указанного тега из удаленного репозитория

--------------------
Работа с изменениями
--------------------

** Проверка репозитория на необходимость фиксации изменений
$	git status

** Добавить файл к будущему коммиту (добавить в индекс)
$	git add <file>
		.	# добавляет в индекс все новые файлы
		        # или *
** Записать коммит (зафиксировать изменения)		
$	git commit - записать коммит (зафиксировать изменения)
		-a						# добавить в индекс и зафиксировать изменения (используется для уже добавленных ранее файлов)
		-m 'commit message'		# записать коммит с сообщением
		--amend					# записать изменения в последний коммит (!!!перед этим добавить изменения в индекс!)

-----------------------------------
Работа с временным хранилищем Stash
-----------------------------------
$	git stash
		list			# посмотреть список stash хранилищ
		push <file>		# добавить файл в существующий на текущей ветке stash
		pop <stash>		# применить изменения из stash хранилища с указанным номером

-----------------
Работа с историей
-----------------

** Просмотр истории коммитов:
$	git log
		--oneline	      # просмотр истории коммитов кратким списком
		--all		      # посмотреть истории коммитов со всех веток
		-<number_commits>     # вывести указанное число последних коммитов
		-p                    # показать изменения в сравнении с предыдущим коммитом (diff)

** Просмотр изменений в коммите
$	git show <hash_commit>

** Вывести произошедшие изменения:
$	git diff
		--stage			# показать различия между stage и последним коммитом

** Просмотр истории действий:
$	git reflog

** Сброс текущего состояния истории до указанного коммита:
$	git reset 
		--hard	# жесткий сброс без сохранения изменений

** Cоздать новый коммит, отменяющий  последствия указанного коммита:
$	git revert <hash_commit>

** Cброс состояния файла до последнего коммита:
$	git restore <file>

** Cброс еще не зафиксированных (помещенных в stage командой add) изменений в файле:
$	git checkout -- <file>

----------------
Работа с ветками
----------------
** Показать ветки (знак "*" перед именем ветки - обозначает текущую ветку):
$	git branch
		   <branch>		# создается новая ветка
		   <branch_fork> <branch_parent>	# создать новую ветку от указанной ветки
		   -d <branch>	# удалить указанную ветку
		   -D <branch>  # уладить дочернюю ветку, которая не была влита в родительскую

** Переключится на указанную ветку:
$	git checkout <branch>
		-b <branch>	#  создать новую ветку и переключиться на нее 


** Слияние указанной ветки в текущую ветку:
$	git merge <branch>
		<branch> --squash		# перенос всех изменений (слияние) с указанной ветки в текущую одним коммитом через squash

**	Cмена начала старта текущей ветки с последнего коммита указанной ветки без добавления нового коммита
$	git rebase <branch>
		-i HEAD~X - склеить Х коммитов начиная с текущего
	# в открывшемся файле можно в нижних коммитах заменить pick на f (fix up - перемещает все сообщения из ранних коммитов в текущий)

------------------------------------
Работа с коммитами из соседних веток
------------------------------------
git cherry-pick <commit>	# перенести коммит из другой ветки на текущую ветку
git cherry-pick <branch>	# перенести последний коммит ветки
git cherry-pick ..<branch>	# перенести все коммиты с ветки

-------------------------------------
Работа с метками (также см. git push)
-------------------------------------
** Вывести список тегов
$	git tag
		<tag>		# фиксация версии (релиза) продукта тегом (меткой) по последнему коммиту
		-d <tag>	# удалить тег из локального репозитория

-------------
Структура Git
-------------

Репозитории бывают:
	1. Лоакальные (local);
	2. Удаленные (remote);
	
Структура репозитория:
.git - директория в которой содержится вся конфигурация и снимки репозитория

Структура истории коммитов:
(HEAD -> <branch>)	# в истории коммитов указывает на текущую ветку
commit				# хэш коммита
Author				# автор коммита (имя и email)
Date				# дата и время создания коммита


Файлы Git:
README.md	- обычно содержит описание для текущего репозитория либо директории
.gitkeep	- пустой файл, создается в постой директории для ее фиксации в репозитории
.gitignore	- в файле указываются названия файлов и дерикторий, которые не должны индексироваться в git. Вносятся построчно

Stash - локальное хранилище git для временного хранения изменений в ветке без их индексирования и фиксации
