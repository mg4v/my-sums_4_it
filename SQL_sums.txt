
   _____  ____  _      _ _
  / ____|/ __ \| |    (_) |
 | (___ | |  | | |     _| |_ ___
  \___ \| |  | | |    | | __/ _ \
  ____) | |__| | |____| | ||  __/
 |_____/ \___\_\______|_|\__\___|

-------------
ЧТО ТАКОЕ БД:
-------------

База данных (БД):
    Совокупность массивов и файлов данных, организованная по определённым правилам,
        предусматривающим стандартные принципы описания, хранения и обработки данных.

Реляционная БД:
    Relation (англ.) - отношение, зависимость, связь.
    Реляционная база данных - совокупность взаимосвязанных таблиц,
        каждая из которых содержит информацию об объектах определённого типа.

#! Relation - это и есть сама таблица.

СУБД (ППО) - система управления базами данных.
    Это приложение, которое обеспечивает работу с базами данных.

Основные функции СУБД:
    1. управление данными во внешней памяти (на дисках);
    2. управление данными в оперативной памяти с использованием
        дискового кэша;
    3. журнализация изменений, резервное копирование и восстановление
        базы данных после сбоев;
    4. поддержка языков БД (язык определения данных, язык
        манипулирования данными).

SQL (Structured Query Language) - язык структурированных запросов.
    Используется для доступа к базе данных и управления ею.
    SQL используется:
        - для создания новых БД;
        - чтобы извлекать данные из существующих БД;
        - чтобы удалять, обновлять записи и т. д.

Реляционные СУБД (Наиболее популярные):
    1. SQLite - встраиваемая СУБД (фактически набор библиотек)
    2. PosterSql - набирает популярность
    3. Oracle - $$$
    4. MySql - ранее самая популярная из бесплатных
    5. MS SQL - $$$, только под Windows

    1. PosterSql
----------------------
ТЕОРИЯ РЕЛЯЦИОННЫХ БД:
----------------------

**
Структура БД должна быть построена так, чтобы, в первую очередь отвечать 2-м требованиям, касательно данных:
    1. Занимать как можно меньше пространства;
    2. Целостность БД.

------------------------------------------------
ИЗВЕСТНЫЕ ПРОБЛЕМЫ ПРИ СОСТАВЛЕНИИ СТРУКТУРЫ БД:
------------------------------------------------
    - составные значения в ячейках таблиц - нужно разбивать на простые (атомарные);
    - избыточность данных - в одной ячейке;
    - неоднозначные зависимости - неверное логическое отношение данных друг с другом;
    - транзитивная зависимость - возможность получения значений атрибутов одной сущности,
        через другую сущность (вложенные связи);
    - ввод однотипных значений - в разные ячейки.

#! Структуру БД нужно приводить к "Нормальной форме":

-------------------------------
НОРМАЛЬНЫЕ ФОРМЫ БД (ПРИНЦИПЫ):
-------------------------------
Порядок форм строго регламентирован, приведение структуры БД к формам идет строго по порядку
    - приведение к каждой следующей форме возможно только после приведения к предыдущим формам !!
    1. Каждое поле содержит элементарные значения, не подлежащие дальнейшему разбиению (декомпозиции);
    2. Все поля в пределах одной таблицы находились в зависимости от ОДНОГО "ключевого поля" - "ПЕРВИЧНЫЙ КЛЮЧ";
        - количество таблиц = количеству ключевых полей;
    3. Исключение транзитивных зависимостей и вынос всех неключевых полей,
        содержимое которых относится к нескольким записям, в отдельные таблицы;

Указав значение атрибута один раз в "ключевой таблице" - в остальных таблицах мы можем,
    вместо этого атрибута, указывать ID "ключевого поля".

    ID ключевого поля - "ПЕРВИЧНЫЙ КЛЮЧ", может быть:
        - Синтетический - дополнительное поле с натуральным числом,
            номером идентифицирующим ключевое поле;
        - Натуральный - собственно, значение самого ключевого поля (дополнительный ID не задается).


--------------------------------------------
ПРЕИМУЩЕСТВА ПРИВЕДЕНИЯ К НОРМАЛЬНЫМ ФОРМАМ:
--------------------------------------------
    - исключается избыточность в хранении данных;
    - обеспечивается согласованность данных;
    - применяется единый подход к хранению данных независимо от области применения.

---------------------------------
ОБЩИЙ ПОДХОД К ПРОЕКТИРОВАНИЮ БД:
---------------------------------
    - сущности реального мира отображаются на таблицы;
    - атрибуты сущностей отображаются на столбцы;
    - данные отдельных экземпляров сущности отображаются на строки таблицы;
    - между таблицами определяются связи по ключевым столбцам;
    - каждая таблица должна соответствовать требованиям нормальных форм.

#! Тип связи между таблицами, когда для ссылок используются значения ключевых столбцов таблиц,
   называется "связью по ключевым столбцам".

-------------------------------------
ОСНОВНЫЕ ЭТАПЫ ПО СОЗДАНИЮ ТАБЛИЦ БД:
-------------------------------------
Синтаксис:
    - Имя команды вносится буквами в ВЕРХНЕМ РЕГИСТРЕ;
    - Имена таблиц, сущностей, их атрибутов - на английском языке;
    - Имя таблицы = название сущности (ключевого поля) во множественном числе.

Важно! Ввод команд языка SQL должен завершаться точкой с запятой.

**
При создании таблицы надо определить подходящие типы данных для каждого столбца

---------------------------------------------
В СУБД SQLite используются пять типов данных:
---------------------------------------------

------------------------------------------------------------------------------------
|Данные          |Тип данных |Описание                                             |
|================|===========|=====================================================|
|Нет значения    |NULL       |NULL - "ничего". Это непустая строка или ноль, NULL -|
|                |           |отсутствие значения.                                 |
|----------------|-----------|-----------------------------------------------------|
|Целое число     |INTEGER    |Целое число со знаком, например, 1, 56, -764.        |
|----------------|-----------|-----------------------------------------------------|
|Дробное число   |REAL       |Число с плавающей точкой, например, 34.568, -4.2     |
|----------------|-----------|-----------------------------------------------------|
|Строка, текст   |TEXT       |Строка текста, например, "Базы данных"               |
|----------------|-----------|-----------------------------------------------------|
|Двоичные данные,|BLOB       |Этот тип предназначен для хранения данных в          |
|медиа           |           |исходном формате. В столбце такого типа сохраняется, |
|                |           |например, изображение                                |
|                |           |                                                     |
------------------------------------------------------------------------------------

#! В соответствии с логикой приложения часто требуется указать дополнительные
    условия для некоторых столбцов.
Например, при создании таблицы надо определить специальное условие,
    которое разрешает сохранение только непустого значения фамилии.
Такие условия называются "ограничениями".

-------------------
Ограничения данных:
-------------------

---------------------------------------------------------------------------------------------------
|Общепринятое название    |Синтаксис SQL  |Назначение ограничения                                 |
|=========================|=======================================================================|
|Ограничение на пустое    |NOT NULL       |Гарантирует, что в ячейку вставится непустое           |
|(NULL) значение          |               |значение                                               |
|-------------------------|---------------|-------------------------------------------------------|
|Ограничение уникальности |UNIQUE         |Гарантирует уникальность значений в пределах таблицы   |
|-------------------------|---------------|-------------------------------------------------------|
|Значение по умолчанию    |DEFAULT        |Определяет значение по умолчанию для столбца,          |
|                         |               |                                                       |
---------------------------------------------------------------------------------------------------

----------------------------------------------
Ограничение первичного ключа и автоприращение:
----------------------------------------------

Для каждой таблицы требуется ключевой столбец.
Термин "ключевой" означает, что значения этого столбца уникальны в пределах таблицы.
Значения в ключевых столбцах представляют собой идентификаторы,
    по которым осуществляется поиск подходящей строки таблицы.
Ключевой столбец называется также столбцом первичного ключа, или просто первичным ключом.
Значения в ячейках этого столбца - идентификаторы строк.

Синтаксически первичный ключ определяется как PRIMARY KEY.
Чаще всего значения первичного ключа определяются условными целочисленными значениями - 1.2.3 и так далее.
Чтобы пользователям не потребовалось следить за нумерацией и исключать появление ошибок
    при вставке значений первичного ключа,
    используется специальный признак автоматического приращения значения AUTOINCREMENT.

-----------------------------------------------------------------------------
|Общепринятое  |Синтаксис SQL|Назначение ограничения                        |
|название      |             |                                              |
|==============|=============|==============================================|
|Первичный ключ|PRIMARY KEY  |Определяет первичный ключ таблицы             |
|--------------|-------------|----------------------------------------------|
|Автоинкремент |AUTOINCREMENT|При добавлении новой строки СУБД              |
|              |             |автоматически подставит следующее значение    |
|              |             |ключа, равное значению ключа последней строки,|
|              |             |прибавив единицу.                             |
----------------------------------------------------------------------------|

-----------------------------------------------------
Определение типов связей (отношений) между таблицами:
-----------------------------------------------------

1. Отношение "один к одному"

Каждому экземпляру сущности А соответствует один и только один экземпляр сущности Б
    и, наоборот, каждому экземпляру сущности Б соответствует один и только один экземпляр сущности А.

2. Отношение "один ко многим"

Одному экземпляру сущности А соответствует несколько экземпляров сущности Б,
    однако каждому экземпляру сущности Б соответствует только один экземпляр сущности А.

3. Отношение "многие ко многим"

Каждому экземпляру сущности А соответствует несколько экземпляров сущности Б, и наоборот.

--------------
Внешние ключи:
--------------
Предназначены для настройки связи таблиц.

Столбцом внешнего ключа, или просто внешним ключом, называется столбец, значения которого
    ссылаются на значения столбца первичного ключа в другой таблице.

Задается внешний ключ следующим образом (при создании таблицы после всех строк с параметрами столбцов):
FOREIGN KEY (ВнешнийКлюч) REFERENCES  ЦелеваяТаблица(ЦелевойПервичныйКлюч)

-----------------------------------------------
Общий порядок создания (проектирования) таблиц:
-----------------------------------------------
    1. Выбираем имя таблицы.
    2. Определяем список  столбцов и их тип.
    3. Определяем дополнительные условия для столбцов.
    4. Определяем первичный ключ таблицы.
    5. Определяем внешние ключи.
    6. Создаём таблицу командой CREATE TABLE.
    7. Проверяем результат.


*********
---------
ПРАКТИКА:
---------
*********

--------------
СУБД - SQLITE:
--------------

Реляционная БД для встраиваемых решений.
Представляет собой библиотеку, которую можно встраивать в свое приложение
    и работать со структурированными данными.

-----------------------
СИЛЬНЫЕ СТОРОНЫ SQLITE:
-----------------------
    - база данных сохраняется в одном файле;
    - хорошая производительность в системах, где не требуется конкурентная запись данных;
    - возможно использовать на конечных устройствах в качестве локального хранилища данных;
    - простая установка и использование, кроссплатформенность.

----------------------
СЛАБЫЕ СТОРОНЫ SQLITE:
----------------------
    - нет встроенной системы управления пользователями и правами;
    - ограниченная поддержка стандартов языка;
    - проблемы с производительностью при конкурентной записи.

---------------------------
УСТАНОВКА SQLITE В WINDOWS:
---------------------------

1. Перейти на официальную страницу скачиваний SQLite - https://www.sqlite.org/download.html.
2. Выбрать раздел "Precompiled Binaries for Windows".
3. Скачать файл вида sqlite-tools-win32-x86-XXXXXXX.zip.
4. Распаковать архив.

-------------------------
УСТАНОВКА SQLITE В MACOS:
-------------------------

1. вариант:
sudo port install sqlite3

2. вариант:
brew install sqlite3

-----------------------------------------
УСТАНОВКА SQLITE В LINUX (DEBIAN/UBUNTU):
-----------------------------------------

sudo apt install sqlite3

**
УСТАНОВКА БИНАРНОГО ПАКЕТА В LINUX (DEBIAN/UBUNTU):
---------------------------------------------------

1. Перейти на официальную страницу скачиваний SQLite - https://www.sqlite.org/download.html;
2. Выбрать раздел "Precompiled Binaries for Linux";
3. Скачать файл вида sqlite-tools-linux-x86-XXXXXXX.zip;
4. Распаковать архив:
unzip sqlite-tools-linux-x86-XXXXXXX.zip
5. Войти в новую директорию и вывести содержимое:
cd sqlite-tools-linux-x86-XXXXXXX

================
----------------
РАБОТА С SQLITE:
----------------
================

;Запустить SQLite:
В Windows:
.\sqlite3.exe

В Linux/MacOS:
sqlite3

-------------------
DOT КОМАНДЫ SQLITE:
-------------------

!!! Дот-команды - команды СУБД SQLite, которые начинаются с точки.
    Эти команды не считаются командами языка SQL.

;Справка:
.help

;Открыть или создать БД:
.open ИМЯ_БД

;Вывести список существующих таблиц:
.tables

;Посмотреть подробную информацию о таблице (команду создания):
.schema имя_таблицы

;Завершить выполнение SQLite:
.exit

-----------------------------
Форматирование вывода данных:
-----------------------------

В клиенте sqlite3 задаются различные форматы для вывода результатов запросов.

Чтобы посмотреть текущий формат вывода, применяется команда:
.mode

Основные форматы вывода содержимого таблиц:
  - list   - данные выводятся построчно и разделяются вертикальной чертой;
  - column - табличный вывод, строки обрезаются;
  - insert - вывод команд вставки INSERT;
  - line   - вывод названий столбцов с соответствующими значениями (вертикальный вывод),
             строки не обрезаются;
  - tabs   - табличный вывод, строки не обрезаются.

!!! Без выбора формата - вывод данных будет выполняться в формате по умолчанию (см. .mode).

;Что бы задать формат вывода, перед запросом данных укажите этот формат:
.mode имя_формата

;Для включения отображения имен столбцов в выводе
    - перед командой выбора формата (см. .mode имя_формата) ввести:
.header on


-------------------------------
SQL ЗАПРОСЫ (В ФОРМАТЕ SQLITE):
-------------------------------

Нет единственно верного способа форматировать код команд SQL,
    но есть рекомендации, как это сделать.
    Пример таких рекомендаций - здесь https://www.sqlstyle.guide/ru/

В соответствии со стандартом языка запросов SQL идентификаторы - имена таблиц и столбцов -
    заключаются в двойные кавычки "", а строковые значения выделяются одинарными кавычками ''.
   В SQLite для совместимости с другими СУБД используются одинарные кавычки '' для определения
    идентификаторов и двойные "" - для строк .
   Обратные кавычки ``так же применяются для идентификаторов.

Все команды ниже в SQLite выполнятся одинаковым образом:

SELECT * FROM "courses";
SELECT * FROM 'courses';
SELECT * FROM `courses`;

-------------------------
Системная таблица SQLite:
-------------------------
Содержит информацию о структурах созданных в текущей БД.
SELECT * FROM sqlite_master;

----------------
Создать таблицу:
----------------
CREATE TABLE

Общий шаблон команды:

CREATE TABLE ИмяТаблицы(
  Столбец 1 Тип Ограничения Первичный Ключ,
  Столбец N Тип Ограничения
);


Пример:
   Создадим таблицу courses из 3-х столбцов:
     - id             - INTEGER - PRIMARY KEY, AUTOINCREMENT;
     - name           - TEXT    - NOT NULL, UNIQUE;
     - lessons_amount - INTEGER -;

Команда:

CREATE TABLE courses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    lessons_amount INTEGER
);


;Назначить PRIMARY KEY нескольким столбцам:
PRIMARY KEY ('Столбец 1', 'Столбец N')


;Назначить внешние ключи (после внесения параметров столбца):
FOREIGN KEY (имя_столбца) REFERENCES имя_имя_целевой_таблицы(целевой_ключевой_столбец);

Пример создания таблицы с предыдущими командами:

CREATE TABLE grades (
    student_id INTEGER NOT NULL,
    stream_id INTEGER NOT NULL,
    grade REAL NOT NULL,
    PRIMARY KEY(student_id, stream_id),
    FOREIGN KEY (student_id) REFERENCES students(id),
    FOREIGN KEY (stream_id) REFERENCES streams(id)
);

--------------------------------
Изменение структуры базы данных:
--------------------------------

Структура базы данных не считается предопределённой на весь срок жизни проекта.
Она меняется, чтобы учесть новые требования. В СУБД SQLite для этого доступны следующие операции:
  - изменение имени таблицы;
  - изменение имени столбца;
  - добавление нового столбца в таблицу.

## Для внесения изменений используются команды:

ALTER TABLE 'Имя Таблицы'
    RENAME TO 'Новое Имя Таблицы';                                    # Изменение имени таблицы
    RENAME COLUMN 'Старое Имя Столбца' TO 'Новое Имя Столбца';        # Изменение имени столбцов
    ADD COLUMN 'Имя Нового Столбца' [Тип Ограничения];                # Добавить новый столбец
    ALTER COLUMN 'Имя Столбца' TYPE [Новый Тип Данных];               # Изменить тип данных в столбце
    DROP COLUMN 'Имя Столбца';                                        # Удалить столбец

   !!! Изменить тип, или имя столбца, можно только, если он не заполнен данными.

DROP TABLE 'Имя Таблицы';                                             # Удалить таблицу

----------------------------
Работа с данными в таблицах:
----------------------------

Основные операции с данными:
  - чтение (выборка) данных из таблицы;
  - добавление (вставка) данных;
  - изменение данных;
  - удаление данных.

!!! Для сокращённого определения этих действий часто применяется обозначение CRUD
    - от английских слов Create, Read, Update и Delete.

---------------
ВЫБОРКА ДАННЫХ:
---------------

SELECT

 - в части FROM надо определить имя таблицы, к которой обращаемся;
 - в части SELECT - перечислить имена столбцов, данные которых нас интересуют.

-----------------------------------------
Общий синтаксис команд для выбора данных:
-----------------------------------------

SELECT 'Что выбираем (включает Обработку)' FROM 'Откуда выбираем' 'Сортировка/Группировка и Ограничения'

+--------+------------------+---------------------------+--------------------+---------------------------------------------+--------------------------+-----------------------------+---------+
|        |      Только      |           Данные          |  Из какой таблицы  |             Условие выбора строк            |        Ограничение       |          Сортировка         |  Конец  |
|        |    уникальные    |          из каких         |                    |                (ОПЦИОНАЛЬНО)                |         на вывод         |         результатов         | команды |
|        |     значения     |          столбцов         |                    |                                             |     количества строк     |        (ОПЦИОНАЛЬНО)        |         |
|        |   (ОПЦИОНАЛЬНО)  |                           |                    |                                             |       (ОПЦИОНАЛЬНО)      |                             |         |
|        +------------------+---------------------------+--------------------+---------------------------------------------+--------------------------+-----------------------------+---------+
| SELECT | DISTINCT('Данные | 'Столбец 1', 'Столбец N'  | FROM 'Имя Таблицы' | WHERE                                       | LIMIT 'Количество Строк' | ORDER BY                    | ;       |
|        | из каких         | Либо * (все столбцы)      |                    |   'Имя Столбца'                             |                          |   'Имя Столбца'             |         |
|        | столбцов')       |                           |                    |   'Оператор выбора'                         |                          |   'Порядок Сортировки'      |         |
|        |                  |                           |                    |   'Искомое Значение'                        |                          |                             |         |
|        |                  |                           |                    |                                             |                          | Порядок сортировки:         |         |
|        |                  |                           |                    |                                             |                          | *******************         |         |
|        |                  |                           |                    |                                             |                          |   - ASC   : по возрастанию; |         |
|        |                  |                           |                    |                                             |                          |   - DESC  : по убыванию;    |         |
|        |                  |                           |                    +---------------------------------------------+                          +-----------------------------+         |
|        |                  |                           |                    | Знаки сравнения:                            |                          | GROUP BY                    |         |
|        |                  |                           |                    | ****************                            |                          |   'Имя Столбца'             |         |
|        |                  |                           |                    | =            :  Равно;                      |                          |                             |         |
|        |                  |                           |                    | != или <>    :  Не равно;                   |                          |                             |         |
|        |                  |                           |                    | <            :  Меньше;                     |                          |                             |         |
|        |                  |                           |                    | >            :  Больше;                     |                          |                             |         |
|        |                  |                           |                    | >=           :  Больше или равно;           |                          |                             |         |
|        |                  |                           |                    | <=           :  Меньше или равно.           |                          |                             |         |
|        |                  |                           |                    +---------------------------------------------+                          |                             |         |
|        |                  |                           |                    | Диапазон значений:                          |                          |                             |         |
|        |                  |                           |                    | ******************                          |                          |                             |         |
|        |                  |                           |                    | BETWEEN 'Значение С' AND 'Значение По'      |                          |                             |         |
|        |                  |                           |                    +---------------------------------------------+                          |                             |         |
|        |                  |                           |                    | Условия равенства для значения NULL:        |                          |                             |         |
|        |                  |                           |                    | **********************************          |                          |                             |         |
|        |                  |                           |                    | IS NULL      :  Равно пустому значению;     |                          |                             |         |
|        |                  |                           |                    | IS NOT NULL  :  Не равно пустому значению . |                          |                             |         |
|        |                  |                           |                    +---------------------------------------------+                          |                             |         |
|        |                  |                           |                    | Добавить несколько условий:                 |                          |                             |         |
|        |                  |                           |                    | **************************                  |                          |                             |         |
|        |                  |                           |                    | 'Условие 1' 'Тип Условия' 'Условие N'       |                          |                             |         |
|        |                  |                           |                    +---------------------------------------------+                          |                             |         |
|        |                  |                           |                    | Типы условий:                               |                          |                             |         |
|        |                  |                           |                    | *************                               |                          |                             |         |
|        |                  |                           |                    | - AND  :  Еще(И);                           |                          |                             |         |
|        |                  |                           |                    | - OR   :  ИЛИ.                              |                          |                             |         |
|        |                  |                           |                    +---------------------------------------------+                          |                             |         |
|        |                  |                           |                    | По списку значений (Заменяет И/ИЛИ):        |                          |                             |         |
|        |                  |                           |                    | ********************************            |                          |                             |         |
|        |                  |                           |                    | IN('Значение 1', Значение N')               |                          |                             |         |
|        |                  |                           |                    +---------------------------------------------+                          |                             |         |
|        |                  |                           |                    | Сопоставление с шаблоном:                   |                          |                             |         |
|        |                  |                           |                    | *************************                   |                          |                             |         |
|        |                  |                           |                    | LIKE('%ЗНАЧЕНИЕ%')                          |                          |                             |         |
+--------+------------------+---------------------------+--------------------+---------------------------------------------+--------------------------+-----------------------------+---------+

!!! В параметрах фильтра IN, можно так же указывать вложенные структуры SELECT !!!
    Например:

 SELECT 'Столбец 1'
 FROM 'Имя таблицы'
 WHERE 'Столбец 2' IN (
     SELECT AVG(Столбец 2)
     AS 'Псевдоним'
     FROM 'Имя таблицы'
     GROUP BY 'Столбец 1'
     HAVING 'Псевдоним' < 4.8
 );


!!! Во всех современных СУБД, включая SQLite, применяется много готовых (встроенных) функций,
    таких как LIKE.
    Полный список встроенных функций с описанием их использования - в официальной документации:
    https://www.sqlite.org/lang_corefunc.html

------------------------
Арифметические операции:
------------------------

+----------+----------------+-----------+---------+
| ОПЕРАТОР | МАТЕМАТИЧЕСКИЙ |  ОПЕРАЦИЯ |  КОНЕЦ  |
|  ВЫБОРА  |    ОПЕРАТОР    |           | КОМАНДЫ |
+----------+----------------+-----------+---------+
| SELECT   | X + Y          | Сложение  | ;       |
|          +----------------+-----------+         |
|          | X - Y          | Вычитание |         |
|          +----------------+-----------+         |
|          | X * Y          | Умножение |         |
|          +----------------+-----------+         |
|          | X / Y          | Деление   |         |
|          +----------------+-----------+         |
|          | X % Y          | Модуль    |         |
|          |                | числа     |         |
+----------+----------------+-----------+---------+

--------------------------------------
Функции для работы с датой и временем:
--------------------------------------

+----------+-------------------+-----------------------------+---------+-------------------------+
| ОПЕРАТОР |      ОПЕРАТОР     |           УСЛОВИЕ           |  КОНЕЦ  |        ПОЯСНЕНИЕ        |
|  ВЫБОРА  |    ДАТЫ/ВРЕМЕНИ   |            ВЫБОРА           | КОМАНДЫ |                         |
+----------+-------------------+-----------------------------+---------+-------------------------+
| SELECT   | CURRENT_TIMESTAMP |                             | ;       | Текущее значение        |
|          |                   |                             |         | даты и времени          |
|          +-------------------+-----------------------------+         +-------------------------+
|          | DATE              |     (CURRENT_TIMESTAMP)     |         | Получить дату           |
|          +-------------------+             или             |         +-------------------------+
|          | TIME              |           ('now')           |         | Получить время          |
|          +-------------------+                             |         +-------------------------+
|          | DATETIME          |                             |         | Получить дату и время   |
|          +-------------------+-----------------------------+         +-------------------------+
|          | SUBSTR            | ('Строка', X, Y)            |         | Форматировать           |
|          |                   | где:                        |         | значение даты/времени   |
|          |                   | 'Строка'                    |         | из указанного источника |
|          |                   |  - текущая дата             |         |                         |
|          |                   |    или                      |         |                         |
|          |                   |    'Имя Столбца с Датой'    |         |                         |
|          |                   |                             |         |                         |
|          |                   | X - позиция первого символа |         |                         |
|          |                   |     в дате/времени          |         |                         |
|          |                   |                             |         |                         |
|          |                   | Y - позиция последнего      |         |                         |
|          |                   |     символа в дате/времени  |         |                         |
+----------+-------------------+-----------------------------+---------+-------------------------+

---------------------
Агрегирование данных:
---------------------
Во время работы с базами данных под агрегированием понимается выполнение
  действий над значениями в различных строках таблицы посредством специальных функций,
  которые называются функциями агрегирования, или просто агрегаторами.

Рассмотрим типичные задачи, которые требуют применения функций агрегирования:
  - определение среднего значения;
  - подсчёт количества;
  - определение максимального и минимального значения;
  - подсчёт суммы.

-------------------------------------------
Назначение псевдонимов (алиасов) для данных
  полученных через функции (AS):
--------------------------------------------
  - в выводе, указываем псевдоним имя столбца для полученных через функцию данных:

'ФУНКЦИЯ'('ДАННЫЕ') AS 'Псевдоним'

Пример для функции COUNT():
SELECT course_id, COUNT(*) AS 'streams_total' FROM streams GROUP BY

--------------------------------------------------------
Понятие группировки, нахождение среднего значения AVG():
--------------------------------------------------------

SELECT 'Функция Агрегирования' FROM 'Имя Таблицы' GROUP BY 'Столбец Группировки';

----------------------------------------------
Подсчёт количества значений или строк COUNT():
----------------------------------------------

SELECT 'Имя Столбца', COUNT('Критерий выбора строк' или *) FROM 'Имя Таблицы' GROUP BY 'Столбец Группировки';

----------------------------------------------------------
Поиск максимального и минимального значения  MAX(), MIN():
----------------------------------------------------------

  В качестве аргумента, функция принимает имя столбца:
Пример:
SELECT 'Имя Столбца', MAX('Имя Столбца') AS 'Псевдоним' FROM 'Имя Таблицы' GROUP BY 'Имя столбца';

----------------------
Получение суммы SUM():
----------------------
  - позволит найти сумму значений столбца

SELECT SUM('Имя Столбца') AS 'Псевдоним' FROM  'Имя Таблицы';

-------------------------------------------------
Применение фильтра к расчётным значениям, HAVING:
-------------------------------------------------

!!! Определить условие через WHERE мы можем только для данных, которые уже есть в таблице.
    Для данных полученных в ходе выбора (SELECT) - условие обработки задается через
    функцию HAVING:

Пример:
  - требуется информация только по средним значениям столбца, которые меньше
SELECT 'Имя Столбца', 'Функции Обработки Данных' FROM 'Имя Таблицы' HAVING 'Условие Обработки Полученных Данных';

---------------------
КОНКАНТЕНАЦИЯ ДАННЫХ:
---------------------

Объединение данных и добавление данных в вывод результатов запроса:
'Данные 1' ||  'Данные N'

----------------------------------------------
Добавление новых данных в таблицу INSERT INTO:
----------------------------------------------

Вставка одной строки:
INSERT INTO 'Имя Таблицы' ('Столбец 1', 'Столбец N') VALUES ('Значение 1', 'Значение N');

!!! Если данные вставляются во все столбцы таблицы, то в команде INSERT имена столбцов не
    перечисляются.

!!! Имена столбцов (и их значение) с параметром - AUTOINCREMENT - указывать не обязательно.

Вставка нескольких строк:

INSERT INTO 'Имя Таблицы' ('Столбец 1', 'Столбец N') VALUES
  ('Значение 1', 'Значение N'),
  ('Значение 1', 'Значение N');

--------------------------------------
Обновление существующих данных UPDATE:
--------------------------------------

UPDATE 'Имя Таблицы'
  SET 'Столбец 1' = 'Значение1', 'Столбец N' = 'Значение N'
  WHERE ['Условие'];

# Замена существующих значений по заданной маске
    REPLACE('Столбец', 'Старое Значение', 'Новое Значение'):

UPDATE streams
SET started_at = REPLACE(started_at, '2020', '2024');

----------------------------
Удаление данных DELETE FROM:
----------------------------
DELETE FROM 'Имя таблицы' WHERE [Условие];

-----------------------
МНОГОТАБЛИЧНЫЕ ЗАПРОСЫ:
-----------------------
Запросы позволяющие получить сводную информацию из разных таблиц.
Для этого используются разные способы.
Наиболее распространены два из них
  - использование вложенных запросов и объединение запросов посредством оператора UNION.

------------------
Вложенные запросы:
------------------
!!! Новичкам
    рекомендуется метод поэтапного построения запроса с использованием так называемых заглушек.
    Следующий шаг
    - замена заглушек на код, посредством которого мы получим требуемые значения.
    Чтобы не путаться, какой таблице принадлежит тот
    - или иной столбец, в условии WHERE указываем таблицу явным образом 'Имя Таблицы.Имя Столбца'.

Пример вложенного запроса:

SELECT
  (SELECT surname FROM students WHERE students.id = grades.student_id)
    AS student_name,
  (SELECT name FROM students WHERE students.id = grades.student_id)
    AS student_surname,
  (SELECT name FROM courses WHERE courses.id =
    (SELECT course_id FROM streams WHERE streams.id = grades.stream_id))
    AS course_name,
  grade
  FROM grades
  WHERE grades.student_id =
    (SELECT id FROM students WHERE surname = 'Иванов' AND name = 'Игорь' );

---------------------------------
Вложенные запросы в части SELECT:
---------------------------------

Схематически вложенный запрос в части SELECT основного запроса определяется следующим
образом:

SELECT
  ('Вложенный запрос')
  FROM
    'Имя таблицы'
  WHERE ['Условие'];

Пример:

SELECT
  number,
  (SELECT name FROM courses WHERE courses.id = streams.course_id) AS
    course_name,
  start_date
  FROM streams
  WHERE start_date >= '2020-11-01';

-------------------------------
Вложенные запросы в части FROM:
-------------------------------

Структурно запросы такого типа выглядят следующим образом:

SELECT
  'Столбец 1',
  'Столбец 2',
  'Столбец n'
  FROM
    ('Вложенный запрос')
  WHERE ['Условие'];

Пример:
SELECT
  MAX(final_grade),
  MIN(final_grade)
  FROM
    (SELECT student_id, AVG(grade) AS final_grade
      FROM grades
      GROUP BY student_id);

--------------------------------
Вложенные запросы в части WHERE:
--------------------------------

Вложенные запросы также применяются в части условия WHERE:

SELECT
  'Столбец 1',
  'Столбец 2',
  'Столбец n'
  FROM 'Имя таблицы'
  WHERE
    ('Вложенный запрос');

Пример:

SELECT
  number,
  start_date
  FROM streams
  WHERE course_id =
    (SELECT id FROM courses WHERE name = 'Базы данных');

-------------------------------
Объединение данных через UNION:
-------------------------------

Посредством оператора UNION можно объединить два или более запроса на выборку данных.
Эти запросы
  могут обращаться как к одной таблице, так и к различным таблицам.
Шаблон объединения с использованием UNION выглядит следующим образом:

SELECT
  'Столбец 1',
  'Столбец 2'
  FROM 'Таблица'
  [WHERE 'Условие']
UNION
SELECT
  'Столбец 1',
  'Столбец 2'
  FROM 'Таблица'
  [WHERE 'Условие'];


Пример:
Рассмотрим применение такого способа объединения. Пусть надо найти идентификатор ученицы
  Анастасии Павловой, а также идентификаторы всех учеников, у которых оценка за курсы равна пяти.

SELECT id FROM students WHERE surname = 'Павлова' AND name = 'Анастасия'
UNION
SELECT student_id FROM grades WHERE grade = 5;

Заметим, что при использовании UNION мы получаем только уникальные (без повторений) значения из
  результирующего набора значений каждого запроса.
  Если надо получить все значения, потребуется
    воспользоваться вариантом UNION ALL:

SELECT id FROM students WHERE surname = 'Павлова' AND name = 'Анастасия'
UNION ALL
SELECT student_id FROM grades WHERE grade = 5;

!!! Для объединения требуется:
    - совпадение количества выводимых столбцов каждого запроса;
    - одинаковые по типу выводимые данные каждого столбца.
    Если эти условия не соблюдаются, выводится ошибка:

"Error: SELECTs to the left and right of UNION do not have the same number of
  result columns"

------------------------------
Объединение таблиц через JOIN:
------------------------------

Типы объединения JOIN
Есть несколько типов объединения данных различных таблиц
  в рамках одного запроса через оператор объединения JOIN:
  - перекрёстное объединение (CROSS JOIN);
  - внутреннее объединение (INNER JOIN);
  - левое внешнее объединение (LEFT JOIN);
  - правое внешнее объединение (RIGHT JOIN);
  - полное внешнее объединение (FULL JOIN).

!!! Не все они реализованы в СУБД SQLite, но и ограниченной реализации будет достаточно для
    решения типовых задач по построению многотабличных запросов.

--------------------------------------
Перекрёстное объединение (CROSS JOIN):
--------------------------------------

[ A [ AB ] B ]

Перекрёстное объединение - CROSS JOIN - тип объединения, при котором каждая строка левой
таблицы объединяется с каждой строкой правой таблицы.

!!! Этот тип объединения применяется на практике крайне редко,
    но понимание того, как он работает,
    будет ключом к пониманию логики работы других типов объединения JOIN.

Синтаксически запрос с CROSS JOIN выглядит таким образом:
SELECT * FROM 'Левая таблица' CROSS JOIN 'Правая таблица';

Пример:
Применим CROSS JOIN
  для таблиц учеников и оценок на примере нашей базы данных students.db:
SELECT * FROM students CROSS JOIN grades;

!!! В выводе команды объединения таблиц методом CROSS JOIN,
    количество выводимых строк равняется произведению количества строк левой и правой таблиц !!!
    Это результат объединения данных каждой строки, относящихся к левой таблице,
      с данными каждой строки правой таблицы (grades).

--------------------
Неявное объединение:
--------------------

Вариант написания, при котором мы убираем CROSS JOIN из команды и перечисляем в части FROM
  таблицы учеников и оценок через запятую, называется неявным объединением.
  То есть оператор JOIN указывается неявным образом:
SELECT * FROM students, grades;

!!! То есть неявное объединение таблиц без условия,
    а именно без части запроса WHERE, работает как CROSS JOIN.
Но мы можем определить условие, что нас интересуют только строки,
  где идентификатор ученика таблицы students совпадает со значением столбца student_id таблицы grades:
SELECT * FROM students, grades WHERE students.id = grades.student_id;

------------------------------------
Внутреннее объединение (INNER JOIN):
------------------------------------

[ [ AB ] ]

!!! В реальных проектах и литературе в запросах будет встречаться неявное
    объединение, но рекомендуется применять синтаксис с явным указанием ключевого слова JOIN:
SELECT * FROM students JOIN grades WHERE students.id = grades.student_id;

Такой тип объединения называется внутренним, так как в результате появятся только те строки двух таблиц,
  между которыми найдено соответствие, определённое в части запроса WHERE. При использовании
  JOIN рекомендуется определять условие объединения таблиц, выбирая часть выражения ON:
SELECT * FROM students JOIN grades ON students.id = grades.student_id;

!!! Внутреннее объединение JOIN также синтаксически определяется и как INNER JOIN, эти варианты
    взаимозаменяемы и дадут одинаковые результаты:
SELECT * FROM students INNER JOIN grades ON students.id = grades.student_id;


--------------------------------------
Левое внешнее объединение (LEFT JOIN):
--------------------------------------

[ A [AB] ]

!!! Основное отличие внешнего объединения от внутреннего
    - при использовании левого внешнего объединения в отчёте окажутся
      все записи из левой таблицы (students), независимо от того, будет ли найдено соответствие с правой
      таблицей (grades) по условию объединения в части запроса ON.

Базовый вариант запроса выглядит следующим образом:
SELECT * FROM 'Левая таблица' LEFT JOIN 'Правая таблица' ON 'Условие объединения';

Применим LEFT JOIN для объединения таблиц учеников и оценок:
SELECT * FROM students LEFT JOIN grades ON students.id = grades.student_id;

---------------------------------------
Правое внешнее объединение (RIGHT JOIN):
---------------------------------------

[ [AB] B ]

Базовый вариант запроса выглядит следующим образом:
SELECT * FROM 'Левая таблица' RIGHT JOIN 'Правая таблица' ON 'Условие объединения';

!!! Правое и полное внешние объединения не поддерживаются в SQLite.
    Обходным решением является
    - переписать RIGHT JOIN с использованием LEFT JOIN,
      просто надо поменять местами левую и правую таблицы.

---------------------------------------
Полное внешнее объединение (FULL JOIN):
---------------------------------------
[ A [AB] B ]
!!! Третий тип внешнего объединения - FULL JOIN. Его работа рассматривается как одновременное
    применение левого и правого внешних объединений. Полное внешнее объединение не
    поддерживается во многих СУБД, включая SQLite, и на практике применяется редко.

----------------------------------------------------
Варианты полного синтаксиса для внешних объединений:
----------------------------------------------------
Для внешних объединений применяется полный синтаксис с использованием ключевого слова OUTER
    - LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN. Но так как левое, правое и полное
    объединения всегда внешние, они никак не могут быть другими, то в большинстве случаев OUTER
    при написании команд опускается.
Пример команды с использованием полного синтаксиса:
SELECT * FROM students LEFT OUTER JOIN grades ON students.id = grades.student_id;

----------------------------
РАСШИРЕННЫЕ ВОЗМОЖНОСТИ SQL:
----------------------------

!!! Язык SQL не представляет собой язык программирования общего применения.
    Это специализированный язык запросов. Но в его инструментарий также заложены
    возможности, позволяющие выйти за рамки типичного применения команд для работы с данными,
    таких как вставка данных, редактирование или выборка.

Рассмотрим некоторые дополнительные структуры, которые реализуются в СУБД SQLite:
    - представления;
    - временные таблицы;
    - транзакции;
    - триггеры.

--------------
Представления:
--------------
https://www.sqlite.org/lang_createview.html

Именованная выборка - срез данных, которому мы
    даём имя и используем в дальнейшем как виртуальную таблицу.

Базовая команда создания представления выглядит следующим образом:
CREATE VIEW 'Имя Представления' AS SELECT ...;

!!! То есть нам надо дать представлению имя и после ключевого слова AS определить запрос, который
    хотим использовать.

После этого можно извлекать данные из представления как из обычной таблицы:
SELECT * FROM 'Имя Представления';

Если представление надо удалить, применяем синтаксис DROP VIEW:
DROP VIEW 'Имя Представления';

------------------
Временные таблицы:
------------------
https://www.sqlite.org/lang_createtable.html

Предназначена для хранения промежуточных данных, которые не надо хранить.
Создаётся в оперативной памяти системы и удаляется
    сразу после завершения работы текущей сессии пользователя в СУБД.

Синтаксис:

CREATE TEMPORARY TABLE 'Имя Временной Таблицы'(
  Столбец 1 Тип Ограничения Первичный Ключ,
  Столбец N Тип Ограничения
);

Если временная таблица больше не требуется, она удаляется обычным образом ещё до окончания
    текущей сессии:
DROP TABLE 'Имя Временной Таблицы';

-----------
Транзакции:
-----------
https://www.sqlite.org/lang_transaction.html

Транзакция - набор команд, которые выполняются только вместе. Если при выполнении любой
    команды возникает ошибка, то для всех уже выполненных команд выполняется откат, и данные
    остаются в исходном состоянии.

Например - транзакция объединяющая команды удаления данных о конкретном ученике из всех таблиц БД.

Для транзакций определяются четыре базовых свойства
    - атомарность, целостность, изолированность и устойчивость:
        1. Атомарность - обеспечивает выполнение правила "всё или ничего".
            Выполняются все команды, или ни одна из них, третьего варианта нет.
        2. Целостность - обеспечивает корректные изменения в данных при успешном выполнении
            транзакции и гарантирует отсутствие нарушений связности данных различных таблиц.
        3. Изолированность - обеспечивает независимое выполнение транзакций, транзакции не
            влияют друг на друга.
        4. Устойчивость - обеспечивает предсказуемость поведения транзакции,
            когда возникают сбои системы.

Начинается транзакция командой BEGIN TRANSACTION,
    завершается, в базовом варианте, командой выполнения COMMIT:
BEGIN TRANSACTION;
  Операция 1;
  Операция N;
COMMIT;

Пример:
BEGIN TRANSACTION;
  DELETE FROM grades WHERE student_id = 1;
  DELETE FROM students WHERE id = 1;
COMMIT;

!!! Если мы не хотим сохранять изменения в данных по командам транзакции, то вместо подтверждения
    COMMIT указываем ОТКАТ изменений  - ROLLBACK.

---------
Триггеры:
---------
https://www.sqlite.org/lang_createtrigger.html

Триггеры рассматриваются как задачи, которые выполняются автоматически при наступлении
    конкретного события - вставки строки, обновлении данных, удалении строки.

Посредством синтаксиса CREATE TRIGGER мы задаём имя триггера,
    определяем событие, по которому будет срабатывать триггер.
    После ключевого слова ON определяем таблицу,
    по ней будет отслеживаться событие,
    а в теле триггера BEGIN… END определяем необходимые действия:

CREATE TRIGGER 'Имя триггера' [BEFORE|AFTER] 'Событие'
  ON 'Таблица'
BEGIN
-- Действия ....
END;

Например:
Нужно настроить автоматическую проверку формата вводимых данных в столбец предназначенный
    для хранения дат.
В тело триггера добавим логику, которая проверяет введенное значение даты на соответствие
    формату ‘ГГГГ-ММ-ДД’:

CREATE TRIGGER check_start_date_format BEFORE INSERT
  ON streams
BEGIN
  SELECT CASE
  WHEN
    (NEW.start_date NOT LIKE '____-__-__')
    OR (CAST(SUBSTR(NEW.start_date, 1, 4) AS INTEGER) NOT BETWEEN 2021 AND 2022)
    OR (CAST(SUBSTR(NEW.start_date, 6, 2) AS INTEGER) NOT BETWEEN 1 AND 12)
    OR (CAST(SUBSTR(NEW.start_date, 9, 2) AS INTEGER) NOT BETWEEN 1 AND 31)
  THEN
    RAISE(ABORT, 'Wrong format for start_date!')
  END;
END;

Рассмотрим логику работы этого триггера более подробно.
    Перед вставкой новой строки в таблицу потоков срабатывает триггер check_start_date_format.
    Значение даты (NEW.start_date) передаётся в конструкцию CASE,
        где в части WHEN выполняется проверка соответствия формата по четырём признакам.
    Если хоть одна из проверок не проходит, то выполняется команда в части THEN,
        которая прерывает операцию вставки строки,
        и пользователь получает ошибку с сообщением, что формат ввода даты неправильный.
    А если с форматом даты всё в порядке, то операция вставки завершается успешно.

------------------------
Анализ сложных запросов:
------------------------
Удобно анализировать сложные запросы в таком порядке:
    - сначала определяем, откуда берутся данные (часть запроса FROM),
        а также группировку (если есть);
    - затем смотрим, что выводится в отчёт (часть запроса SELECT);
    - в конце смотрим фильтр (WHERE) и сортировку (ORDER BY).

----------------
ОКОННЫЕ ФУНКЦИИ:
----------------
Оконные функции позволяют выполнить действия над наборами строк,
    объединяя их по некоторому определённому признаку.
    Собственно, окна, это и есть наборы строк (иногда их еще называют - разделы).
Применение оконных функций существенно расширяет возможности работы с данными
    (в отличие от GROUP BY, в одном запросе, с помощью оконных функций,
    можно группировать и обрабатывать разные наборы строк по разным столбцам),
    иногда в литературе оконные функции называются аналитическими.

Синтаксис применения оконных функций:
-------------------------------------
Для работы с оконными функциями используется ключевое слово OVER.
Перед OVER указываем, какую функцию надо использовать.
После OVER в скобках требуется определить правило для разделения строк выборки на части (окна):
'Функция' OVER ('Окно')

Принцип работы оконных функций:
-------------------------------

Оконные функции позволяют для каждой строки запроса выполнить вычисления, используя другие строки.
В отличие от агрегатных функций, которые свёртывают сгруппированный набор строк в одну строку,
    оконные функции производят агрегирование на основе содержимого "окна",
    включающего одну или более строк из результирующего набора.
!!! При использовании оконных функций, функции группировки (GROUP BY) отдельно не применяются!!!
!!! Желательно в запросе с оконными функциями использовать функцию DISTINCT для исключения повторяющихся строк!!!

Пример запроса с использованием оконных функций:

SELECT DISTINCT
  students.id,
  students.surname,
  students.name,
  COUNT(stream_id) OVER(w_students) AS courses_passed,
  MIN(grade) OVER(w_students) AS min_grade
  FROM students
    LEFT JOIN grades
    ON grades.student_id = students.id
  WINDOW w_students AS (PARTITION BY students.id)
  ORDER BY students.surname, students.name;

# Ключевое слово "WINDOW" - определяет название и параметры окна,
# без этого слова, строки функций "COUNT" и "MIN" выглядели бы так:
# COUNT(stream_id) OVER(PARTITION BY students.id) AS courses_passed,
# MIN(grade) OVER(PARTITION BY students.id) AS min_grade


Встроенные оконные функции SQLite:
----------------------------------

Оконные функции - это не только функции агрегирования, которые применяются в качестве оконных,
    но и те, что применяются только на окнах.
Например, функция ROW_NUMBER возвращает порядковый номер строки в пределах окна,
    а функция FIRST_VALUE - первое значение столбца в пределах окна.

-------
ИНДЕКСЫ
-------

Индекс - структура базы данных, в которой хранятся отсортированные значения столбца
    (или нескольких столбцов), с указателями на место в файле,
    где содержатся соответствующие строки таблицы.

Такая структура позволяет выполнять более быстрый и "дешевый", с точки зрения
    системных ресурсов "двоичный" поиск, нежели поиск методом "перебора".

Поиск "перебором":
    Чтобы вернуть найденную строку как результат, СУБД должна найти файл, где хранятся данные
        соответствующей таблицы, прочитать данные с носителя,
        загрузить их в оперативную память и затем перебирать каждую строку таблицы,
        проверяя совпадение по условию поиска.
        После перебора всех строк те данные, которые соответствуют условию поиска, вернутся клиенту.

"Двоичный" поиск:
    Возможен, если в целевом столбце все данные отсортированы.
        Тогда, количество всех строк целевого столбца делится на 2.
        Обе половины сравниваются на предмет наличия искомого значения.
        Половина в которой содержится искомое значение - остается для дальнейшего поиска,
        а другая половина - "отбрасывается."
        Оставшаяся часть снова делится на 2, и далее, процесс сравнения по целевому значению повторяется,
        до тех пор, пока не останется строка, содержащая необходимое значение.

Синтаксис команды создания индекса:
-----------------------------------
CREATE INDEX 'Имя индекса' ON 'Имя таблицы'('Имена столбцов');

!!! хорошей практикой будет
    присваивать индексу имя, состоящее из имен таблицы и индексируемых столбцов,
    разделенных символом "_" и добавлять в конце имени индекса значения "_idx".
Например:
CREATE INDEX students_surname_idx ON students(surname);

После создания индекса, при выводе структуры таблицы (.schema 'Имя таблицы'),
    мы также увидим команду созданных к этой таблице индексов.
Например:
sqlite> .schema students
CREATE TABLE students (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  surname TEXT NOT NULL,
  name TEXT NOT NULL
);
CREATE INDEX students_surname_idx ON students(surname);
sqlite>

!!! После того как индекс создан, во всех запросах, где выполняется поиск или сортировка
    по индексируемому значению, поиск будет выполняться в соответствующем индексе.

Уникальные индексы:
-------------------
Если данные столбца не повторяются, то создаётся уникальный индекс
    посредством ключевого слова UNIQUE:
CREATE UNIQUE INDEX 'Имя индекса' ON 'Имя таблицы'('Имена столбцов');

Составные индексы:
------------------
Индексы создаются и на несколько столбцов сразу, такие индексы
называются составными.
Например:
CREATE INDEX students_surname_name_idx ON students(surname, name);

Неявные индексы:
----------------
В некоторых случаях СУБД SQLite создаёт индексы автоматически.
Если столбец таблицы объявлен первичным ключом,
    внешним ключом или на столбец определено ограничение уникальности значений,
    то СУБД построит индексы на такие столбцы без участия пользователя.

Когда требуется применять индексы:
----------------------------------
На создание индексов, их хранение и поддержание в актуальном состоянии требуются ресурсы
    - процессорное время, место на носителях информации, оперативная память системы.
Если создать индексы на все столбцы всех таблиц, то возникнет ситуация,
    когда затраты на обслуживание индексов перевесят преимущества, которые индексы дают для поиска.

Общепринятым подходом считается создавать индексы на этапе эксплуатации системы,
 когда уже понятно, какие запросы выполняются наиболее часто и значительно нагружают базу данных.
Для ускорения работы таких запросов на столбцы поиска и/или сортировки создаются соответствующие индексы.


==========================================
------------------------------------------
РАБОТА В ГРАФИЧЕСКОМ КЛИЕНТЕ SQLITESTUDIO:
------------------------------------------
==========================================

Один из самых популярных графических клиентов, является - SQLiteStudio.
Программа устанавливается с официального сайта:
https://sqlitestudio.pl/

Установка SQLiteStudio:
-----------------------
    - На стартовой странице проекта кликаем в правом верхнем углу Download.
    - Далее на странице загрузок выбираем установщик (installer) для своей операционной системы.
    - После загрузки файла запускаем его
        (на ОС Linux предварительно надо сделать файл установщика исполняемым).
        После приветствия нажимаем Next.
    - Далее выбираем путь установки и ассоциацию с типами файлов.
        Если менять эти значения не надо, то нажимаем Next.
    - На следующем шаге выбираем требуемые компоненты или нажимаем Next,
        чтобы установка прошла с предопределёнными настройками.
    - Подтверждаем установку, нажимаем Install
    - После окончания установки кликаем Finish.
    - Запустится программа SQLiteStudio, а затем потребуется выбрать язык интерфейса.
    - После выбора языка программа будет готова к использованию.

Создать базу данных:
--------------------
[Database] -----> [Add a database].
После этого потребуется выбрать имя файла базы данных и имя самой БД.
Нажимаем кнопку "+" справа от поля "Файл".
Подтверждаем выбор в окне "Базы данных", жмём "Ок".
Новая база данных создана, она появилась в левой панели интерфейса.

Открыть существующую базу данных:
---------------------------------
[Database] -----> [Add a database]
    в строке "Файл" - указать путь до локального файла БД.
После подтверждения база данных появится в левом меню приложения.

Выполнение команд:
------------------
[Tools] -----> [Open SQL editor]
В открывшемся окне редактора вводим подходящую команду, устанавливаем курсор после точки с
    запятой и нажимаем значок треугольника — выполняем запрос.

===============================================
-----------------------------------------------
УСТАНОВКА И РАБОТА В ГРАФИЧЕСКОМ КЛИЕНТЕ MYSQL:
-----------------------------------------------
===============================================

 Версионирование в MySQL:
 ------------------------

 Версия современного программного обеспечения обычно состоит из трех цифр,
    например 8.0.19. Первая цифра называется мажорной, вторая — минорной, а
    последняя — патч-версией.
 Мажорная версия изменяется редко, между этими событиями проходят годы, иногда
    десятилетия. Изменением мажорной версии, как правило, отмечаются существенные
    архитектурные преобразования в программном обеспечении.
 Минорной версией отмечается релиз, в рамках которого добавляется новый
    функционал (методы, операторы) и исправляются найденные ошибки.
 В рамках патч-версии, как правило, исправляются критические уязвимости и ошибки.

Установка:
----------
Сервер MySQL доступен для установки во всех современных операционных системах.

Для WINDOWS:
страница загрузки: https://dev.mysql.com/downloads/installer/


==========
----------
ГЛОССАРИЙ:
----------
==========

+------------------------------------------+-----------------------------------------------------------------------------------+
|                  Термин                  |                                    Определение                                    |
+------------------------------------------+-----------------------------------------------------------------------------------+
| CRUD                                     | основные операции для работы с данными,                                           |
|                                          |  сокращение от английского Create, Read, Update и Delete,                         |
|                                          |  соответственно - создание, чтение, обновление и удаление данных.                 |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Автоинкремент                            | дополнительный признак столбца,                                                   |
|                                          |  при использовании которого СУБД самостоятельно генерирует значение,              |
|                                          |  прибавляя единицу к предыдущему значению.                                        |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Агрегирование данных                     | выполнение действий над набором данных.                                           |
|                                          | При работе с базами данных обрабатывается                                         |
|                                          | набор данных конкретного столбца таблицы.                                         |
+------------------------------------------+-----------------------------------------------------------------------------------+
| База данных                              | набор данных, хранящихся в соответствии с                                         |
|                                          |  некоторой предварительно определённой структурой.                                |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Вложенный запрос                         | запрос, который помещается в некоторую часть другого                              |
|                                          | (основного) запроса.                                                              |
|                                          | Часто такие запросы называются подзапросами.                                      |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Внешний ключ, столбец внешнего ключа     | столбец, значения которого ссылаются на                                           |
|                                          | значения столбца первичного ключа в другой таблице.                               |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Внутреннее объединение                   | тип объединения, где в результате появляютс                                       |
| (JOIN, INNER JOIN)                       |  только те данные из левой и правой таблиц,                                       |
|                                          |  которые соответствуют условию, заданному в части ON запроса.                     |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Временная таблица                        | таблица, которая существует только на время                                       |
|                                          |  текущей сессии пользователя, структура                                           |
|                                          |  и данные временной таблицы не сохраняются на носитель.                           |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Встраиваемые СУБД                        | системы управления базами данных,                                                 |
|                                          |  которые не имеют реализации в виде отдельного приложения                         |
|                                          |  и используются для интеграции в другие системы.                                  |
|                                          |  Распространённый вариант реализации таких СУБД - библиотека.                     |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Группировка                              | определение признака для разбивки всех                                            |
|                                          |  строк на группы для последующего применения                                      |
|                                          |  над ними некоторой функции агрегирования.                                        |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Двоичный поиск                           | бинарный поиск, метод деления на два - алгоритм поиска,                           |
|                                          |  основанный на последовательном разделении набора                                 |
|                                          |  данных на половины и определении, в какой из половин находится искомое значение. |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Дот-команды                              | команды СУБД SQLite, которые начинаются с точки.                                  |
|                                          |  Эти команды не считаются командами языка SQL.                                    |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Избыточность данных                      | дублирование данных.                                                              |
|                                          | Избыточность появляется в случае хранения одних                                   |
|                                          | и тех же данных в различных таблицах одной базы данных.                           |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Индекс                                   | структура базы данных, которая содержит упорядоченные                             |
|                                          |  значения столбца или нескольких столбцов,                                        |
|                                          |  а также ссылки на место в файле БД,                                              |
|                                          |  где хранятся соответствующие строки таблицы.                                     |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Левое внешнее объединение                | тип объединения, при использовании которого в                                     |
| (LEFT JOIN, LEFT OUTER JOIN)             |  результате появляются все строки из левой таблицы.                               |
|                                          |  Из правой таблицы выделяются данные,                                             |
|                                          |  если появляется соответствие по условию объединения ON,                          |
|                                          |  и выявляются пустые значения для тех строк,                                      |
|                                          |  где соответствие не обнаруживается.                                              |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Многие ко многим                         | тип связи, при котором каждому экземпляру сущности А                              |
|                                          |  соответствует несколько экземпляров сущности Б, и наоборот.                      |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Многотабличный запрос                    | запрос, в котором происходит обращение к                                          |
|                                          |  данным нескольких таблиц, например, две таблицы и больше.                        |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Нормализация                             | процесс последовательного применения                                              |
|                                          |  требований нормальных форм к данным.                                             |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Нормальные формы                         | набор правил, выполнение которых позволит привести данные к виду,                 |
|                                          | соответствующему требованиям реляционной модели.                                  |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Ограничение                              | правило для столбца таблицы,                                                      |
|                                          |  которое определяет допустимость вводимых значений.                               |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Один к одному                            | тип связи, когда каждому экземпляру сущности А                                    |
|                                          |  соответствует один и только один экземпляр сущности Б и,                         |
|                                          |  наоборот, каждому экземпляру сущности Б                                          |
|                                          |  соответствует один и только один экземпляр сущности А.                           |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Один ко многим                           | тип связи, когда одному экземпляру сущности А                                     |
|                                          |  соответствует несколько экземпляров сущности Б,                                  |
|                                          |  однако каждому экземпляру сущности Б                                             |
|                                          |  соответствует только один экземпляр сущности А.                                  |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Оконные функции                          | позволяют выполнить действия над наборами строк,                                  |
|                                          |  которые объединяются по некоторому определённому признаку.                       |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Первичный ключ, столбец первичного ключа | столбец, значения которого уникальны в пределах таблицы                           |
|                                          |  и используются для однозначной идентификации строк в пределах таблицы.           |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Перекрёстное объединение                 | тип объединения, при котором каждая строка                                        |
| (CROSS JOIN)                             |  левой таблицы объединяется с каждой строкой правой таблицы.                      |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Полное внутреннее объединение            | тип объединения, который рассматривается как одновременное                        |
| (FULL JOIN, FULL OUTER JOIN)             |  применение левого и правого внешних объединений,                                 |
|                                          |  то есть в отчёт попадут все записи как из левой,                                 |
|                                          |  так и из правой таблицы, удовлетворяющих условию выборки.                        |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Правое внешнее объединение               | тип объединения, при использовании которого                                       |
| (RIGHT JOIN, RIGHT OUTER JOIN)           |  в результате выделяются все строки из правой таблицы.                            |
|                                          |  Из левой таблицы появляются данные,                                              |
|                                          |  если обнаруживается соответствие по условию объединения ON,                      |
|                                          |  и выводятся пустые значения для тех строк,                                       |
|                                          |  по которым соответствия не выявляются.                                           |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Представление                            | именованный срез данных.                                                          |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Проект с открытым кодом,                 | распространяется на условиях «свободных» лицензий,                                |
| открытое программное обеспечение         |  например, GNU General Public License или BSD License.                            |
|                                          |  В большинстве случаев ПО с открытым кодом                                        |
|                                          |  - свободное и используется любым желающим.                                       |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Простое (атомарное) значение             | значение, не разделяемое на отдельные части                                       |
|                                          |  без потери первоначального смыслового контекста.                                 |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Реляционная база данных                  | база данных, соответствующая требованиям                                          |
|                                          |  реляционной модели данных.                                                       |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Реляционная модель данных                | логическая модель данных,                                                         |
|                                          |  основанная на математическом аппарате                                            |
|                                          |  теории множеств и логики первого порядка.                                        |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Составное значение                       | значение, разделяемое на отдельные простые                                        |
|                                          |  значения без потери первоначального смыслового контекста.                        |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Составной первичный ключ                 | ключ, который состоит из комбинации                                               |
|                                          |  значений нескольких столбцов.                                                    |
+------------------------------------------+-----------------------------------------------------------------------------------+
| СУБД                                     | система управления базами данных.                                                 |
|                                          |  На практике СУБД реализуются в виде приложения,                                  |
|                                          |  которое разворачивается на соответствующей аппаратной платформе.                 |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Технология клиент-сервер                 | архитектура, которая предполагает разделение                                      |
|                                          |  программно-аппаратного комплекса на клиентскую и серверную часть.                |
|                                          |  Клиентская часть предоставляет интерфейс для работы с системой,                  |
|                                          |  серверная часть обрабатывает запросы клиентов.                                   |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Транзитивная зависимость                 | определяется наличием атрибутов,                                                  |
|                                          |  значения которых получаются на основе других атрибутов.                          |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Функции агрегирования, агрегаторы        | функции, применяемые для обработки набора данных.                                 |
|                                          |  Например, подсчёт количества, нахождение суммы                                   |
|                                          |  или среднего значения и т. д.                                                    |
+------------------------------------------+-----------------------------------------------------------------------------------+
| Язык запросов SQL                        | структурированный язык запросов,                                                  |
|                                          |  который применяется для работы с реляционными базами данных.                     |
+------------------------------------------+-----------------------------------------------------------------------------------+