

------------------------------------------
ВЗАИМОДЕЙСТВИЕ С КОМАНДНОЙ ОБОЛОЧКОЙ BASH:
------------------------------------------

; Вызов командной оболочки в GUI:
 CTRL+ALT+T

-----
CLEAR
Очистить содержимое терминала:
# На самом деле - просто смещается на один экран вниз!
 CTRL+L        # альтернативная комбинация клавиш для вызова CLEAR;

-------------------------------
СТАНДАРТНЫЕ ПОТОКИ ВВОДА/ВЫВОДА
STDIN, STDOUT, STDERR:
-------------------------------

ТЕРМИНАЛ - оконечное (физическое) устройство, предназначенное для взаимодействия оператора и компютера.
 Терминал подключался к ЭВМ. Таких терминалов могло быть несколько.
 Терминал может быть запущен удаленно;

ЭМУЛЯТОР ТЕРМИНАЛА - "программный" терминал, эмулирующий работу "физического" терминала;
 Для каждого сеанса пользователя создается отдельный терминал.

КОНСОЛЬ - совокупность устройств ввода/вывода для передачи оператором команд и вывода компьютером результатов.
 Консоль всегда подключена к текущему РМ.

КОМАНДНЫЙ ИНТЕРПРЕТАТОР - программа позволяющая передавать команды пользователя компьютеру.
 В большинстве современных дистрибутивов linux командным интерпретатором по умолчанию является - bash.

КОНСОЛЬ --> ТЕРМИНАЛ --> BASH

Для взаимодействия запускаемых программ с пользователем используются стандартные потоки ввода/вывода:
 - STDIN (0): стандартный поток ввода, по умолчанию настроен на устройство ввода текущей консоли;
 - STDOUT (1): стандартный поток вывода, по умолчанию настроен на устройство вывода текущей консоли;
 - STDERR (2): стандартный поток ошибок, по умолчанию настроен на устройство вывода текущей консоли;

Важно понимать, что в Linux - все есть файл!
 Соответственно - стандартные потоки, это специальные файлы, которые открываются на чтение или запись.
 Именно поэтому мы можем использовать вместо стандартной консоли файлы.

; Передача потока вывода в файл:
{{ COMMAND }}  > {{ FILE }}            # перезаписывает содержимое файла, либо создает новый если нет с таким именем;
{{ COMMAND }}  >> {{ FILE }}            # добавляет вывод в конец существующего файла;

По умолчанию в файл передается поток STDOUT, а STDERR выводится на экран.
; Передача потока ошибок в файл:
{{ COMMAND }} 2 }} {{ FILE }}

; Объединение потоков вывода и передача их в файл:
{{ COMMAND }} 2 }}&1 {{ FILE }}

КОНВЕЙЕР - передача результатов предыдущей команды (STDOUT) в текущую:
{{ COMMAND_1 }} | {{ COMMAND_2 }} | ... | {{ COMMAND_N }}

---------------------------------
ПОЛЬЗОВАТЕЛИ И ГРУППЫ В ОС LINUX:
---------------------------------

Linux -  многопользовательская операционная система.
 Каждый процесс в пользовательском пространстве выполняется от имени того или иного пользователя.
 Поддержка прав на чтение/запись/выполнение поддерживается на уровне файловой системы,
  и позволяет гибко настраивать доступ к файлам отдельных пользователей и пользовательских групп.

ПОЛЬЗОВАТЕЛЬ - входит в систему, проходит процедуру авторизации и идентифицируется с какой-то учетной записью.
УЧЕТНАЯ ЗАПИСЬ - хранит информацию о пользователе, предназначенную для его опознания и предоставления
 доступа к его личным данным и настройкам.
ПРАВА ДОСТУПА - совокупность правил которые регламентирую порядок и условия доступа какого-то субъекта
(например пользователя) к объектам информационной системы (например файлам).
ГРУППА - именованная группа пользователей с одинаковыми правами доступа к тем или иным объектам ИС.
 Группы необходимы для организации нескольких пользователей к различным ресурсам.

Каждый пользователь имеет 2 основных атрибута:
 - UID (User identifier - идентификатор пользователя): ОС различает пользователей именно по UID!
   это число из диапазона 0 - 65535.
 - GID (Group identifier - идентификатор группы): Каждый пользователь в ОС принадлежит, как минимум, к 1 группе пользователей.
   При создании пользователя, по умолчанию создается группа для него. Как правило, имя группы пользователя по умолчанию
    совпадает с его именем. Пользователь может принадлежать к нескольким группам.

Условно можно разделить пользователей на 3 типа:
 - ROOT: суперпользователь (superuser): имеет неограниченные права в ОС.
   UID:GID = 0:0.
   Предназначен для работы с системными файлами, службами и всеми объектами, которые влияют на работу ОС;
 - SYSTEM USERS (Системные пользователи): нужны для обеспечения работы каких-то запущенных процессов/демонов.
   Как правило - не имеют оболочки, не могут авторизоваться в системе создаются автоматически при установке приложений;
 - USERS (простые пользователи): учетные записи, которые создаются администратором ОС для работы пользователей в этой ОС.
   могут быть локальными (создаваться на самом сервере), сетевыми (хранятся в домене LDAP - аналог AD).

В ОС Linux информация об учетных записях хранится в 3 файлах:
 - /etc/passwd: содержит общую информацию об УЗ:
   LOGIN:PASSWORD(метка его наличия или отсутсвия):UID:GID(основная):DESCRIPTION:HOME_DIRECTORY:SHELL
   SHELL для пользователей, как правило - /bin/bash,
    для системных пользователей: /usr/sbin/nologin или /bin/false - не позволит авторизоваться в консоли под этой учеткой!;
 - /etc/group: содержит общую информацию о группах пользователей:
   GROUP_NAME:PASSWORD(метка):GID:UID(перечисляются все пользователи, которые входят в группу);
 - /etc/shadow: хранит информацию о паролях УЗ:
   LOGIN:PASSWORD(hash или *):
    Для усложнения подбора пароля по хешу, функция hash использует соль (salt) - некое случайно генерируется при создании хеша
    и дополняет хеш пароля.
    Первые 2 символа hash указывают на тип шифрования:
     - $1 = md5 = 22 символа;
     - $5 = sha-256 = 43 символа;
     - $6 = sha-512 = 86 символов.
    Следующие 16 символов - это соль.
    Далее следует сам hash.

    - число дней последнего изменения пароля, начиная с 1 января 1970 года:
    - число дней, перед тем как пароль может быть изменён:
    - число дней, после которых пароль должен быть изменён:
    - число дней, за сколько пользователя начнут предупреждать, что пароль устаревает:
    - число дней, после устаревания пароля для блокировки учётной записи:
    - число дней, отсчитывая с 1 января 1970 года, когда учётная запись будет заблокирована:
    - зарезервированное поле

   Для усложнения подбора пароля по хешу, функция hash использует соль (salt) - некое случайно генерируется при создании хеша
    и дополняет хеш пароля.
   Первые 2 символа hash указывают на тип шифрования:
    - $1 = md5 = 22 символа;
    - $5 = sha-256 = 43 символа;
    - $6 = sha-512 = 86 символов.
   Следующие 16 символов - это соль.
   Далее следует сам hash.

; Создание пользователя:
useradd {{ USER_NAME }}

# Создается пользователь с указанным именем, группа пользователя,
## ему назначается оболочка по умолчанию, пароль и домашняя директория не создаются:
    -s {{ SHELL_NAME }}   # задается оболочка для пользователя;
    -m                         # создать домашний каталог
    -b {{ HOME_DIRECTORY }}        # назначить домашний каталог (абсолютное имя домашнего каталога).
                               ## если такого каталога нет, для создания требует указать -m.

; Создать (задать)/изменить пароль пользователя:
passwd {{ USER_NAME }}

; Создание пользователя с помощью perl скрипта:
adduser {{ USER_NAME }}

# В процессе выполнения создает домашнюю директорию, группу, оболочку,  запрашивает пароль и дополнительную информацию.

; Удалить пользователя командой:
userdel {{ USER_NAME }}

; Удалить пользователя с помощью perl скрипта:
deluser {{ USER_NAME }}

# где:
    -a        # добавить;
    -G        # дополнительные группы.


; Создать группу пользователей:
groupadd {{ GROUP_NAME }}

; Добавить пользователя в группу:
usermod -aG {{ GROUP_NAME }} {{ USER_NAME }}

; Удалить группу пользователей командой:
groupdel  {{ GROUP_NAME }}

; Удалить группу пользователей с помощью perl скрипта:
delgroup {{ GROUP_NAME }}

--------------------------------------------
ПЕРЕКЛЮЧЕНИЕ НА ДРУГОГО ПОЛЬЗОВАТЕЛЯ
ВЫПОЛНЕНИЕ ОПЕРАЦИЙ ОТ ДРУГОГО ПОЛЬЗОВАТЕЛЯ
ЗАВЕРШЕНИЕ ТЕКУЩЕЙ СЕССИИ ТЕКУЩЕГО ПОЛЬЗОВАТЕЛЯ:
--------------------------------------------
!!! Воспользоваться командой sudo могут только пользователи группы sudo.
  Эти пользователи перечислены в файле /etc/sudoers !!!
  Пользователи добавляются в этот файл с помощью утилит:
visudo
# или
sudoedit

; переключиться на пользователя root:
sudo -s
# или
sudo su

; Завершить текущую сессию текущего пользователя:
exist
# или
CTRL+D


---
PWD
Вывести полное название текущей директории (print work directory):

 pwd

-----
TOUCH
Создать файл или обновить время обращения к существующему файлу:

 touch {{ FILE }}

--
LS
Вывод содержимого директории (list):

 ls                       # текущей директории;
       {{ DIRECTORY }}        # указанной директории;
    -l                    # подробный вывод списком;

--
RM
Удалить файл или директорию (remove):

rm    {{ FILE_or_DIR }}        # удаляет только пустую директорию!
   -r                      # рекурсивное удаление директории со всем содержимым (recursion);


-----
MKDIR
Создать директорию (make directory):

 mkdir {{ DIRECTORY }}

--
MV
Переместить или переименовать файл или директорию (move):

 mv {{ SRC_FILE_or_DIR }} {{ DST_FILE_or_DIR }}

--
CP
Скопировать файл или директорию (copy):

 cp {{ SRC_FILE_or_DIR }} {{ DST_FILE_or_DIR }}

--
CD
Смена текущего каталога (change directory):

 cd                   # перейти в домашнюю директорию текущего пользователя;
       {{ DIRECTORY }}    # перейти в указанную директорию;
    ..                # перейти в родительский каталог;

---
LDD
Посмотреть какие библиотеки требуются приложению для его работы.

Например, если требуется перенести приложение в другую директорию для дальнейшего chroot.

#
ldd {{ путь_до_исполняемого файла }}
#

------
CHROOT

Смена корневой (/) директории

#
chroot {{ путь_до_нового_корня }} {{ путь_до_запускаемого_приложения }}
#
---------
NAMESPACE

Механизм пространств имён
Пространство имён (англ. namespace) — это механизм ядра Linux, обеспечивающий изоляцию процессов друг от друга.
 Работа по его реализации была начата в версии ядра 2.4.19.
 На текущий момент в Linux поддерживается шесть типов пространств имён:
 - PID	PID процессов - создание нового (изолированного для находящихся в нем дочерних процессов) дерева процессов.
 - NETWORK	Сетевые устройства, стеки, порты и т.п.
   Благодаря пространству имён NET мы можем выделять для изолированных процессов собственные сeтевые интерфейсы.
   Даже loopback-интерфейс для каждого пространства имён будет отдельным.

 - USER	ID пользователей и групп
 - MOUNT	Точки монтирования - изолированная файловая система
 - IPC	SystemV IPC, очереди сообщений POSIX
 - UTS	Имя хоста и доменное имя NIS
   UTS используется для изоляции системных идентификаторов: имени узла (nodename) и имени домена (domainame),
    возвращаемых системным вызовом uname().
  Все эти типы используются современными системами контейнеризации (Docker, LXC и другими) при запуске программ.


------
STRACE

Средство трассировки(распечатки) системных вызовов, полезно для выявления ошибок.

#
; Начать трассировку процесса, заданного идентификатором(PID):
strace -p {{ number_of_pid }}

; Трассировать процесс с фильтрацией выдач по определённому системному вызову:
strace -p {{ number_of_pid }} -e {{ name_of_sys_call }}

; Вывести при завершении программы таблицу, содержащую число обращений, ошибок и затраченное время по каждому из системных вызовов:
strace -p {{ number_of_pid }} -c

; Отображать при трассировке время, затраченное системным вызовом:
strace -p {{ number_of_pid }} -T

; Начать трассировку одновременно с выполнением программы:
strace {{ name_of_program }}
#

------
LTRACE

Выводит список вызванных процессом функций из разделяемых библиотек

#
; Вывести трассировку вызовов библиотек при выполнении программы:
ltrace {{ name_of_program }}

; Подсчитать количество вызовов библиотек, вывести итоговую таблицу при завершении процесса:
ltrace -c {{ path_to_program }}

; Трассировать вызовы функций malloc и free, кроме тех, что были вызваны из библиотеки libc:
ltrace -e malloc+free-@libc.so* {{ path_to_program }}

; Вывод в файл (не на терминал):
ltrace -o {{ name_of_file }} {{ path_to_program }}
#


-----
PKILL

Поиск, отправка сигналов или ожидание процессов на основе имени и других атрибутов

#
pkill [OPTIONS] {{ PATTERN }}

; Используйте команду kill -l для получения списка всех доступных сигналов.
; Наиболее часто используемые сигналы:
 - 1(HUP): перезагрузить процесс.
 - 9(KILL): убить процесс.
 - 15(TERM): изящно остановить процесс.

; Завершить (убить) конкретную сессию пользователя:
pkill -9 -t {{ TTY_NAME }}
