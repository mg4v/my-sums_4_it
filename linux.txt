------------------------------------------
ВЗАИМОДЕЙСТВИЕ С КОМАНДНОЙ ОБОЛОЧКОЙ BASH:
------------------------------------------

; Вызов командной оболочки в GUI:
 <CTRL> + <ALT> + <t>
; Переключиться на виртуальный терминал:
 <CTRL> + <ALT>+{{ <FUNCTION-KEY_NUMBER> }}
   # Как правило в ОС существует 7 виртуальных терминалов:
     - с 1 по 6: текстовые, а 7 - GUI.
-----
CLEAR
Очистить содержимое терминала:
# На самом деле - просто смещается на один экран вниз!
 <CTRL> + <l>       # альтернативная комбинация клавиш для вызова CLEAR;

----
EXIT
Выйти из текущего сеанса (текущего пользователя)/EOF:
  <CTRL> + <d>        # альтернативная комбинация клавиш для вызова EXIT;

-----------------------------
НАВИГАЦИЯ В КОМАНДНОЙ СТРОКЕ (УПРАВЛЯЮЩИЕ СИМВОЛЫ):
-----------------------------
<CTRL> + <f>        # перемещение на один символ вправо;
<CTRL> + <b>        # перемещение на один символ влево;
<ALT> + <f>         # перемещение на одно слово вправо;
<ALT> + <b>         # перемещение на одно слово влево;
<CTRL> + <a>        # перемещение в начало строки;
<CTRL> + <e>        # перемещение в конец строки;
<CTRL> + <PgUp>     # на один экран вверх;
<CTRL> + <PgDown>   # на один экран вниз;
<CTRL> + <w>        # удалить слово;
<CTRL> + <u>        # удалить часть строки слева от курсора;
<CTRL> + <k>        # удалить часть строки справа от курсора;
<CTRL> + <s>        # остановить вывод на экран (при длительном выводе результата выполнения программы);
<CTRL> + <q>        # возобновить вывод на экран (при длительном выводе результата выполнения программы);
<CTRL> + <m>        # выполнить команду (равносильно ENTER) или <CTRL> + <o>;
<CTRL> + <c>        # отменить ввод команды;


-------------------------------
ИСТОРИЯ КОМАНД, АВТОДОПОЛНЕНИЕ:
--------------------------------
; Автодополнение вводимой команды - подтягивает окончание первой попавшейся команды или файла, подходящей по первым введенным символам:
<TAB>,<TAB>

; Поочередно показывать введенные команды из истории от текущей к первой
<ARROW_UP> или <CTRL> + <p>

; Поочередно показывать введенные команды из истории от текущей к последней
<ARROW_DOWN> или <CTRL> + <n>

; Подтянуть из истории последнюю команду содержащую последовательность символов ABC:
<CTRL> + <r> ABC
# Если таких команд в истории несколько, дальнейшее нажатие <CTRL> + <r> подтягивает последующие
## подходящие команды с конца.

; Вывести историю ввода команд текущего пользователя:
history

; Выполнить последнюю введенную команду:
!!

; Выполнить команду с конкретным номером в истории (history):
!{{ COMAND_NUMBER }}

; Выполнить последнюю команду начинающуюся с указанной последовательности символов:
!abc

; Подтянуть значение аргумента с указанным номером из последней команды:
!:{{ ARG_NUMBER }}
  # номера аргументов начинаются с 1 (0 это имя самой программы/команды);

----------------------------------
ПОДСТАНОВОЧНЫЕ СИМВОЛЫ В КОМАНДАХ:
----------------------------------

?                # один любой символ;
*                # любое количество любых символов или их отсутствие;
[ABC123]         # одно вхождение одного из указанных символов;        
!                # кроме указанных после ! значений;
{A..Z}           # интервал (цепочка символов), позволяет организовать цикл обработки файлов и каталогов,
                 ## последовательно беря в каждой итерации последующий символ из заданного интервала.
                 ## интервалы или цепочки символов можно разделять запятой: {ACEG,1..9}


--------------------------------------
ЭКРАНИРОВАНИЕ СПЕЦСИМВОЛОВ В КОМАНДАХ:
--------------------------------------

\                            # экранирование спецсимвола справа;
''                           # восприятие всех символов  в кавычках как текст (в том числе, спецсимволов кроме ');
""                           # восприятие всех символов  в кавычках как текст (кроме: \!`$);

---------------------
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:
---------------------

; EXPORT - команда для просмотра/модификации симтемных переменных.

# Вывести полный перечень системных переменных:
export

; Добавить/присвоить значения системной переменной:
export {{ VAR_NAME }}=${{ VAR_NAME }}:{{ 

- $PATH    # содержит перечень путей в которых ОС ищет исполняемые и справочные файлы программ;N ЬФТ
- $HOME    # содержит абсолютное имя домашней директории текущего пользователя;
- $LANG    # задает основной язык системы, используется другими программами для выбора языка по умолчканию;
- $EDITOR  # задает редактор текстов по умолчанию; 

-------------------------------
СТАНДАРТНЫЕ ПОТОКИ ВВОДА/ВЫВОДА
STDIN, STDOUT, STDERR:
-------------------------------

ТЕРМИНАЛ - оконечное (физическое) устройство, предназначенное для взаимодействия оператора и компютера.
 Терминал подключался к ЭВМ. Таких терминалов могло быть несколько.
 Терминал может быть запущен удаленно;

ЭМУЛЯТОР ТЕРМИНАЛА - "программный" терминал, эмулирующий работу "физического" терминала;
 Для каждого сеанса пользователя создается отдельный терминал.

КОНСОЛЬ - совокупность устройств ввода/вывода для передачи оператором команд и вывода компьютером результатов.
 Консоль всегда подключена к текущему РМ.

КОМАНДНЫЙ ИНТЕРПРЕТАТОР - программа позволяющая передавать команды пользователя компьютеру.
 В большинстве современных дистрибутивов linux командным интерпретатором по умолчанию является - bash.

КОНСОЛЬ --> ТЕРМИНАЛ --> BASH

Для взаимодействия запускаемых программ с пользователем используются стандартные потоки ввода/вывода:
 - STDIN (0): стандартный поток ввода, по умолчанию настроен на устройство ввода текущей консоли;
 - STDOUT (1): стандартный поток вывода, по умолчанию настроен на устройство вывода текущей консоли;
 - STDERR (2): стандартный поток ошибок, по умолчанию настроен на устройство вывода текущей консоли;

Важно понимать, что в Linux - все есть файл!
 Соответственно - стандартные потоки, это специальные файлы, которые открываются на чтение или запись.
 Именно поэтому мы можем использовать вместо стандартной консоли файлы.

; Передача потока вывода в файл:
{{ COMMAND }}  > {{ FILE_NAME }}            # перезаписывает содержимое файла, либо создает новый если нет с таким именем;
{{ COMMAND }}  >> {{ FILE_NAME }}            # добавляет вывод в конец существующего файла;

По умолчанию в файл передается поток STDOUT, а STDERR выводится на экран.
; Передача потока ошибок в файл:
{{ COMMAND }} 2 >> {{ FILE_NAME }}

; Объединение потоков вывода и передача их в файл:
{{ COMMAND }} 2 >>&1 {{ FILE_NAME }}
#или
{{ COMMAND }} &>> {{ FILE_NAME }}

; КОНВЕЙЕР - передача результатов предыдущей команды (STDOUT) в текущую:
{{ COMMAND_1 }} | {{ COMMAND_2 }} | ... | {{ COMMAND_N }}

----------------
СПЕЦ.УСТРОЙСТВА:
----------------
Могут использоваться для перенаправления ввода/вывода

; Пустое устройство (черная дыра)
/dev/null

-------------------
СПРАВОЧНАЯ СИСТЕМА:
-------------------

----
TYPE

Показывает существует ли КОМАНДА в системе, ее тип, местоположение, является названием или алиасом другой КОМАНДЫ

#
type {{ COMMAND_NAME }}

------
WHATIS

Показывает краткое описание того, что делает команда, включая номера разделов MAN

#
whatis [OPTION] {{ COMMAND_NAME }}

-------
WHEREIS

Показывает где содержаться двоичные файлы, исходный код, конфигурации и файлы руководства для указанной КОМАНДЫ
 # ищет только в директориях, которые перечислены в переменной $PATH

#
whereis [OPTION] [-BMS directory... -f] {{ COMMAND_NAME }}

-----
WHICH

Показывает путь до исполняемого файла команды

#
which [OPTIONS] {{ COMMAND_NAME }}

---
MAN

Подробное справочное руководство по коммандам

#
man [OPTIONS] {{ COMMAND_NAME }}

; показывает краткое описание команд, содержащих указанное СЛОВО:
man -k {{ COMMAND_NAME }}
# или
apropos {{ COMMAND_NAME }}

; показывает конкретный раздел справки по указанной команде:
man {{ SECTION_NUMBER }} {{ COMMAND_NAME }}

; НАВИГАЦИЯ:
  <ENTER>                # Листать страницу на одну строку вниз;
  <SPACE>                # Листать страницу на один экран вниз;
  <b>                    # Листать страницу на один экран вверх;
  <p>                    # Вернуться в начало инструкции;
  </>{{ KEY_WORD }}      # Искать все вхождения указанного СЛОВА в текущем справочном руководстве;
  <n>                    # Перейти к следующему вхождению {{ KEY_WORD }};
  <q>                    # Выйти из справки.

----
INFO

Онлайновое подробное справочное руководство по командам в гипертекстовом формате

#
info [OPTION] {{ COMMAND_NAME }}

; НАВИГАЦИЯ:
  <SPACE>                # Листать страницу на один экран вниз;
  <b>                    # Вернуться в начало инструкции;
  <TAB>                  # Перемещаться по разделам справки (помечены знаком "*");
  </>{{ KEY_WORD }}      # Искать все вхождения указанного СЛОВА в текущем справочном руководстве;
  <n>                    # Перейти к слодующему вхождению {{ KEY_WORD }};
  <q>                    # Выйти из справки.

----
HELP

Ключ для вызова сокращенной справки по команде (действует не для всех команд)

#
{{ COMMAND_NAME }} --help

-------------------------------------------------------
НАВИГАЦИЯ В СИСТЕМЕ, СОЗДАНИЕ ФАЙЛОВ И КАТАЛОГОВ, ПОИСК:
-------------------------------------------------------

---
PWD
Вывести полное название текущей директории (print work DIRECTORY_NAME):

#
pwd

--
CD
Смена текущего каталога (change DIRECTORY_NAME):

#
cd [OPTIONS] {{ DIRECTORY_NAME }}

; перейти в домашнюю директорию текущего пользователя
cd
  или
cd ~

; перейти в родительский каталог
cd ..

; перейти в пердыдущий каталог
cd ~-

--
LS
Вывод содержимого директории (list):

#
ls [OPTIONS] {{ DIRECTORY_NAME }}

; вывести содержимое текущей дериктории
ls

; подробный вывод списком
ls -l

; отобразить, в том числе, скрытые (системные) файлы (имя начинается с символа "."), включая жесткие ссылки на текущий и родительский каталоги
ls -a

; отобразить, в том числе, скрытые (системные) файлы (имя начинается с символа ".")
ls -A

; показать типы файлов
ls -F
  # символы определяющие тип файла:
    "/"    # каталог;
    "@"    # мягкая ссылка;
    ""     # обычный файл.

; показывать номера inode файлов
ls -i

; рекурсивно показать содержимое директории
ls -R

; показать подробные сведения о текущей дериктории
ls -ld

; показать человекочитаемый размер файлов
ls -lh

; сортировать по размеру файлов
ls -s

-----
TOUCH
Создать файл или обновить время cоздания существующего файлу:

#
touch {{ FILE_NAME }}

--
LN

Cоздать жесткую или символическую (мягкую) ссылку на файл.
 # Жесткая ссылка - это еще одно имя файла - новое место не занимает, файл имеет один и тот же inode для всех жестких ссылок.
 ## Нельзя создавать жесткие ссылки на директории (системные ЖС для директорий - ".", "..")
 ## Все ЖС к файлу должны располагаться на одном разделе.

#
ln [OPTIONS] {{ SRS_FILE_or_DIR }} {{ LINK_NAME }}

; создать жесткую ссылку на файл
ln {{ SRS_FILE_or_DIR }}

; задать имя создаваемой ссылки на файл (target)
ln -T {{ SRS_FILE_or_DIR }} {{ LINK_NAME }}

; создать символическую ссылку на файл
 # Символическая (мягкая) ссылка на файл - это еще один (новый, отдельный) файл, который содержит линк до целевого файла
 ## Занимает место, inode, может ссылаться на файлы на других разделах (носителях).
 ## Бьется если целевой файл меняет свое абсолютное имя.
 ## При создании желаетельно указывать абсолютное имя целевого файла.
ln -s {{ SRS_FILE_or_DIR }} {{ LINK_NAME }}

-----
MKDIR

Создать директорию (make DIRECTORY_NAME):

#
mkdir [OPTIPNS] {{ DIRECTORY_NAME }}

; создать директорию, включая родительские
mkdir -p {{ PARENT_DIRECTORY/CHILD_DIRECTORY }}

--
CP

Скопировать файл или директорию (copy)

#
cp [OPTIPNS] {{ SRC_FILE_or_DIR }} {{ DST_FILE_or_DIR }}

; рекурсивно копировать
cp -r

; выводить список копируемого
cp -v

--
MV

Переместить или переименовать файл или директорию (move):

#
mv [OPTIPNS] {{ SRC_FILE_or_DIR }} {{ DST_FILE_or_DIR }}

; рекурсивно перемещать
mv -r

; выводить список перемещаемого
mv -v

-----
RMDIR

Удалить пустую директорию

#
rmdir [OPTIPNS] {{ DIRECTORY_NAME }}

--
RM

Удалить файл или директорию (remove):

#
rm [OPTIPNS] {{ FILE_or_DIR }}

; рекурсивное удаление директории со всем содержимым (recursion)
rm -r {{DERECTORY_NAME }}

; выводить список удаляемого (verbose)
rm -v

; не запрашивать подтверждение на удаление (force)
rm -f

; запрашивать перед удалением
rm -i

------
LOCATE

Быстрый поиск файла в системе по системной БД
 # обновление БД выполняется командой `sudo updatedb`
 # требуется наличие пакета "plocate"

#
locate [OPTION] {{ FILE_NAME }}

----
FIND

Поиск файлов по заданным параметрам (по умолчанию - рекурсивный)

#
find {{ PATH }} [OPTIONS] {{ EXPRESSIONS }}

; искать в текущей дериктории
find . [OPTIONS] {{ EXPRESSIONS }}

; искать по типу файла
find {{ PATH }} -type {{ TYPE_FILE }}
  f    # файл;
  d    # директория;
  l    # ссылка;
  s    # сокет;
  p    # FIFO (именованный канал);

; искать по имени
find {{ PATH }} -name {{ FILE_NAME }}

-----------------------------------
ВЫВОД СООБЩЕНИЙ И РАБОТА С ТЕКСТОМ:
-----------------------------------

---
CAT

Объединяет файлы и направляет их на стандартный вывод

#
cat [OPTIONS] {{ FILE_NAME }}

; Вывести содержимое файла на экран
cat {{ FILE_NAME }}

; Вывести содержимое файла на экран c нумерацией строк
cat -n {{ FILE_NAME }}

; Показать табуляцию знаками "^I"
cat -T {{ FILE_NAME }}

; Показать конец строки знаком "$"
cat -T {{ FILE_NAME }}
#

----
MORE

Постраничный росмотр текстового файла с перелистыванием страниц

#
more [OPTIONS] {{ FILE_NAME }}

; НАВИГАЦИЯ:
  <ENTER>                # Листать страницу на одну строку вниз;
  <SPACE>                # Листать страницу на один экран вниз;
  <b>                    # Листать страницу на один экран вверх;
  <q>                    # Выйти из справки.
#

----
LESS

Постраничный росмотр текстового файла с перелистыванием страниц - расширенный вариант more

#
less [OPTIONS] {{ FILE_NAME }}

; НАВИГАЦИЯ:
  <ENTER>                # Листать страницу на одну строку вниз;
  <SPACE>                # Листать страницу на один экран вниз;
  <b>                    # Листать страницу на один экран вверх;
  <p>                    # Вернуться в начало инструкции;
  </>{{ KEY_WORD }}      # Искать все вхождения указанного СЛОВА в текущем справочном руководстве;
  <n>                    # Перейти к следующему вхождению {{ KEY_WORD }};
  <q>                    # Выйти из справки.
#

----
ECHO

Вывод текста устройство вывода

#
echo [OPTIONS] {{ SOME_TEXT }}

; вывести текст на экран
echo "SOME TEXT"

; вывести содержимое переменной
echo ${{ VARIABLE_NAME }}

; не выполнять перевод строки после вывода сообщения
echo -n {{ MESSAGE }}
#

; перевести значение из HEX в DECIMAL:
echo $((16#{{ VALUE }}))
# Например:
...
echo $((16#FF))
255
...
--
WC

Вывести количество строк, слов, байт в файле

#
wc [OPTIONS] {{ FILE_NAME }}

; вывести количество строк
wc -l

; вывести количество слов
wc -w

; вывести количество байт
wc -c
#

---
CUT

Вырезать определенные поля из каждой строки файла

#
cut [OPTIONS] {{ FILE_NAME }}

; указать делиметр (по какому разделителю выбирать поля)
cut -d "{{ DELIMITER_NAME }}"
 # например:
   cut -d ":"        # разделителем в пределах каждой строки файла будут ситаться все символы ":"

; указать номер поля, относительно разделителей (первым полем считается вся часть перед первым разделителем,
  далее нумерация полей между разделителями)
cut -f {{ FIELD_NUMBER }}
#

----
SORT

Вывести отсортированный текст
 # По умолчанию использует порядок сортировки, заданный в настройках системного языка.

#
sort [OPTIONS] {{ FILE_NAME }}

; Отсортировать список числовых значений по возрастанию
-n
#

----
GREP

Ввод строк, соответствующих шаблону (регулярные выражения)

#
grep [OPTIONS] {{ PATTERN }} {{ FILE_NAME }}

; Игнорировать регистр в искомых выражениях
-i

; Задает один или несколько образцов для поиска. Образцы в списке_образцов должны разделяться символами новой строки.
-e {{ PATTERN_LIST }}

; Сопоставлять с полными регулярными выражениями
-E

; искать рекурсивно во всех файлах и директориях (относительно текущей дериктории) указанноге содержимое:
-r

; вывести список всех файлов внутри которых найдено искомое выражение с номерами строк:
-l

; вывести список всех файлов внутри которых найдено искомое выражение:
-L

; вывести список всех файлов внутри которых найдено искомое выражение и показать содержимое найденных строк:
-n

; REGEXP:

  []                                      # любой из перечисленных символов (цифры, буквы, спецсимволы), интервал задается знаком "-",
                                          ## например, любой из строчных букв: [a-z];
  "({{ PATTERN_1 }}|{{ PATTERN_2 }})"   # любое из перечисленных вхождений (ИЛИ);
  .                                       # любой символ;
  ?                                       # любой символ или его отсутствие;
  {{ PATTERN }}*                          # любое количество повторений указанного шаблона;
  \{{ SPEC_CHARACTERS}}                   # экранирование спецсивола, что бы он воспринимался как текст.
#

-----
GEDIT

GUI gnome редактор текстов

#
gedit {{ FILE_NAME }}
#

----
NANO

Еще один псевдографический текстовый редактор,том вводим:
 - :w - сохранить редактируемый файл
#
nano  {{ FILE_NAME }}

; основные горячие клавиши подсказаны внизу экранаы
#

------
VI/VIM

Мощный текстовый редактор работающий в четырех режимах:

 - командный - для навигации, быстрого редактирования текста и переключения режимов;
 - текстовый (иногда его называют режим вставки) - для ввода текста;
 - визуальный - для выделениятекста;
 - режим командной строки - для вводам мощных комманд и функций.

Текущий режим показывает своё название в нижнем левом углу статусной строки.

# командный:
  {{ NUM }} + {{ COMAND_NAME }}     # выполнить указанную команду NUM раз;    
  h              # влево на один символ; 
  j              # вниз на одну строку;
  k              # вверх на одну строку;
  l              # вправо на один символ;
  b              # передвинуть курсор на одно слово к началу строки;
  w              # передвинуть курсор на одно слово к концу строки;
  W              # до пробела вправо;
  B              # до пробела влево;
  ^              # перейти в начало строки или 0;              
  $              # перейти в конец строки;
  }              # абзац вниз;
  {              # абзац вверх;
  H              # к первой строке экрана;
  L              # к последней строке экрана;
  M              # к середине экрана;
  <CTRL> + <f>   # перейти на страницу вперед;
  <CTRL> + <b>   # перейти на страницу назад;
  [[             # перейти в начало файла или :1 или gg;
  ]]             # перейти в конец файла или G;
  i              # начать ввод текста с позиции перед текущим символом;
  a              # начать ввод текста с позиции после текущего символом;
  I              # начать ввод текста сначала текущестроки;
  A              # начать ввод текста сконца текущей строки;
  o              # вставить пустую строку после текущей и начать ввод текста;
  O              # вставить пустую строку перед текущей и начать ввод текста;
  v              # начать выделение фрагмента из произвольного количества символов, продолжение выделения клавишами h-j-k-l;
  V              # начать выделение фрагмента состоящего из целых строк;
  y              # скопировать выделенный фрагмент;
  yy             # скопировать строку или Y;
  yw             # скопировать слово;
  y^             # скопировать символы от курсора до начала строки;
  y$             # скопировать символы от курсора до конца строки;
  p              # вставить пустую строку перед текущей и начать ввод текста;
  P              # вставить пустую строку перед текущей и начать ввод текста;
  R              # заменить текст после курсора;
  x              # удалить один символ над курсором;
  dw             # удалить слово (от курсора до пробела или конца строки);
  dd             # удалить строку;
  d$             # удалить символы от курсора до конца строки;
  d^             # удалить символы от курсора до начала строки или d0;
  J              # удалить перевод строки (текущая и нишняя строки сливаются);
  с              # команда аналогичная d, но после удаление переходит в режим ввода;
  сс             # команда удаляет текущую строку и переходит в режим ввода;
  C              # удаляет текст с текущего положения курсора до конца строки, аналогична команде с$ (где $ - символ конца строки);
  .              # повторить последнее действие;
  u              # отменить последнее действие;
  U              # отменить все действия в текущей строке;

# в режимe командной строки:

  :r {{ FILE_NAME }}              # вставить в редактируемый текст содержимое указанного файла;
  :e {{ FILE_NAME }}              # начать редактиррование еще одного файла;
  :ls                             # показать список активных буферов (редактируемых файлов);
  :b {{ NUM }}                    # перейти к буферу (редактируемому файлу) указанного номера;
    ## <CTRL> + <^>    - переключение между двумя последними буферами;
  :set hidden                     # отключить требование редактора сохранять документ перед переключением на предыдущий;  
  :set wrap                       # включить автоперенос строки;
  :set number                     # включить нумерацию строк;
  :syntax on                      # включить подсветку синтаксиса (off - выкл.)
  :nohlsearch                     # отключить выделение цветом в редактируемом файле;
  :w                              # записать (сохранить) изменения;
  :w {{ FILE_NAME }}              # записать (сохранить) изменения в указанный файл;
  :q                              # выйти из текущего буфера (файла);
  :x                              # записать изменения в текущий файл и выйти из него, или <ESC> + ZZ; 
  :{{ COMAND_NAME }}!             # принудительно выполнить указанную команду;
  :/{{ FIND_TEXT }} + <ENTER>     # найти указанный текст в файле, с начала в конец;
  :?{{ FIND_TEXT }} + <ENTER>     # найти указанный текст в файле, с конца в начало;
  /                               # повтор поиска в сторону конца файла;
  ?                               # повтор поиска в сторону начала файла;
  n                               # повтор поиска в том же направлении;
  N                               # повтор поиска в обратном направлении;
  fx                              # передвинуть курсор вперёд к следующему вхождению символа x в текущей строке;
  tx                              # то же самое, но при этом курсор устанавливается прямо перед символом,
                                    а не на сам символ;
  Fx                              # передвинуть курсор назад к предыдущему вхождению символа x в текущей строке;
  :{{ NUM }}                      # перейти в на строку с указанным номером;
  :!{{ COMAND_NAME }}             # выполнить команду UNIX не покидая редактора;
  :r !{{ COMAND_NAME }}           # загрузить вывод команды {{ COMAND_NAME }} в текущий документ;
  :%s'{{ OLD_TEXT }}'{{ NEW_TEXT }}'g    # глобальная замена в текущем документе указанного текста;

# текстовый режим:

  i                               # переход в текстовый режим;
  <CTRL> + <h>                    # удалить последний введенный символ;

-------
HEXDUMP

Позволяет просмотреть "сырые" двоичные данные в файлах в формате HEX, т.к.
 стандартные просмотрщики воспринимает двоичные данные как символы алфавита 
 (а также символы псевдографики и управляющие конструкции ASCII: переводы строк, разные виды табуляций и т. д.)

; "каноничный" вывод содержимого в HEX + преобразование кода в ASCII:
hexdump -C {{ FILE_NAME }}

----
BIEW

ДЕКОМПЕЛЯЦИЯ - перевод машинного кода в более высокий уровень. Например:
ДИЗАССЕМБЛИРОВАНИЕ - перевод бинарного кода в код мнемоник или assembler.
  Как правило выполняется с помощью специальных программ, например в Windows это - Hiew,
   а для GNU\Linux - biew (в качестве $1 принимает путь к исходному файлу),

** Данной утилиты нет в репозиториях UBUNTU, вот один из способов ее установить в систему:
...
lynx https://sourceforge.net/projects/beye/files/latest/download
tar xvfj biew-610-src.tar.gz
cd biew-610
./configure
sudo make
sudo make install
...

; преобразовать содержимое бинарного файла в язык мнемоник:
biew -b {{ FILE_NAME }}

; преобразовать содержимое бинарного файла в язык в HEX:
biew -h {{ FILE_NAME }}

------------------
РАБОТА С АРХИВАМИ:
------------------

Архиваторы (в ос семейства linux) не сжимают файлы, они создают один файл, который включает в себя все указанные файлы.
Компрессоры - сжимают файлы, созданные архиваторами.

---
TAR

Архиватор

#
tar -f [ OPTIONS ] {{ ARCHIVE_NAME }}.tar {{ TARGET_FILES }}
 # обязательно указывать ключ "-f" он позволяет передать на вход команде tar целевой файл,
 ## ключ "-f" всегда указывается последним из всех опций.
 ## Опции можно перечислять без знака "-" перед ними

; создать архив (CREATE)
tar -cf {{ ARCHIVE_NAME }}.tar {{ TARGET_FILES }}

; распаковать архив (EXTRACT)
tar -xf {{ ARCHIVE_NAME }}.tar

; просмотреть содержимое архива (TEST)
tar -tf {{ ARCHIVE_NAME }}.tar

; вывод обрабатываемях файлов при упаковке/распаковке (VERBOSE)
tar -cvf/xvf {{ ARCHIVE_NAME }}.tar {{ TARGET_FILES }}

; создать tar архив и выполнить сжатие с помощью gzip
tar -czf {{ ARCHIVE_NAME }}.tar.gz {{ TARGET_FILES }}

; создать tar архив и выполнить сжатие с помощью bzip2
tar -cjf {{ ARCHIVE_NAME }}.tar.bz2 {{ TARGET_FILES }}

; создать tar архив и выполнить сжатие с помощью xz
tar -cJf {{ ARCHIVE_NAME }}.tar.xz {{ TARGET_FILES }}

---------------
GZIP, BZIP2, XZ

Компрессоры

#
gzip/bzip2/xz [OPTIONS] {{ TARGET_FILES }}

; декомпрессия (разжатие)
gunzip/bunzip2/unxz {{ ARCHIVE_NAME }}

---
ZIP

Архиватор и компрессор - сразу архивирует и сжимает

#
zip [OPTIONS] {{ ARCHIVE_NAME }}.zip {{ TARGET_FILES }}

; Запаковать директорию со всемсодержимым
-r

; распаковать
unzip {{ ARCHIVE_NAME }}


----------------------------------
УПРАВЛЕНИЕ ДИСКОВЫМ ПРОСТРАНСТВОМ:
----------------------------------

--
DD

Преобразовать и копировать файлы.
Работает напрямую с дисковым устройством минуя файловую систему - работает с сырыми данными.

#
dd if={{ SOURCE/INPUT_FILE/DEVICE }} bs={{ BLOCK_SIZE }} \
skip={{ COUNT_SKIPPING_BLOCKS }} \
count={{ COUNT_BLOCKS}} of={{ DEST/OUTPUT_FILE/DEVICE}}

; считать сырые данные из первых 512 байт на диске sda (MBR) и вывести на экран содержимое в формате HEX: 
dd if=/dev/sda bs=1 count=512 | hexdump -C

; тоже самое, но пропустить первые 446 байт (код загрузчика) и считать содержимое таблицы разделов:
dd if=/dev/sda skip=446 bs=1 count=16 | hexdump -C

-----
FDISK

Программа обслуживания разделов дисковых устройств.

#
fdisk [OPTIONS] {{ DEVICE_PATH }}

; Вывести список всех дисковых устройств:
fdisk -l {{ DEVICE_PATH }}

; Вывести встроенную справку:
m

; Просмотреть таблицу разделов текущего устройства:
p

; Создать новый раздел:
n

##
; Выбираем тип раздела:

p   primary (0 primary, 0 extended, 4 free)
e   extended (container for logical partitions)

; Указываем объем раздела, например 1 Gib указывается как:
+1G
##

; Удалить раздел:
d

; Записать изменения в пространстве диска:
w

; Выход из программы:
q

#

Работа с файловыми системами на разделах (дисках):
--------------------------------------------------

----
MKFS

создать ФС на диске

#
mkfs.{{ FILE_SYSTEM }} {{ DEVICE_PATH/PARTITION }}

; Создать на разделе /dev/sda1 ФС ext4:
mkfs.ext4 /dev/sda1
#

-----
MOUNT

монтирование устройст к VFS

#

mount {{ DEVICE_PATH/PARTITION }} {{ MOUNT_POINT }}

; примонтировать том /dev/sda1 к директории /mnt:
mount /dev/sda1 /mnt/

#

---------
RESIZE2FS

изменить размер ФС типа EXT на разделе:

#

; увеличить (растянуть) размер ФС на весь доступный объем на разделе:
resize2fs  {{ DEVICE_PATH/PARTITION }}

; уменьшить (назначить) размер ФС (перед этим размонтировать раздел и выполнить e2fsck) до 1G:
resize2fs {{ DEVICE_PATH/PARTITION }} 1G

#

------
E2FSCK

проверить ФС Linux ext2/ext3/ext4 (например для проверки и исправления фрагментации):

#

e2fsck [OPTIONS]  {{ DEVICE_PATH/PARTITION }}

; Принудительная проверка, даже если файловая система помечена как чистая:
e2fsck -f {{ DEVICE_PATH/PARTITION }}

#

Увеличение раздела блочного устройтва (диска):
----------------------------------------------

** Если это не LVM:
1) удаляем раздел (например в fdisk);
2) создаем новый раздел начинающийся с того же места с новым размером;
3) записываем изменения;
4) выполняем partprobe или kpartx для обновления информации о размере раздела в VFS (/proc/partitionsi);
5) увеличиваем (растягиваеам) объем ФС на разделе (resize2fs). 


Уменьшение раздела блочного устройтва (диска):
----------------------------------------------

** Если это не LVM:
1) umount;
2) e2fsck -f;
3) resize2fs;
4) mount;
5) fdisk (p, n, w);
6) partprobe

## ФС не должна быть больше чем объем раздела!!!

-------
TUNE2FS

настройка изменяемых параметров ФС

#

tune2fs [OPTIONS] {{ DEVICE_PATH/PARTITION }}

; просмотреть изменяемые параметры ФС:
tune2fs -l {{ DEVICE_PATH/PARTITION }}

#

LVM:
----

LVM - Logical Volume Manager

Еще один уровень абстракции.
Берет на себя функции размещения информации на физическом носителе.
Включает в себя три основных объекта:

1. Физический том (PV)
2. Группа томов (VG)
3. Логический том (LV)

PV создается на устройстве (или на томе устройства), группа PV (или их части) объединяется в VG, на уровне VG нарезаются LV,
 на уровне LV создаются ФС и выполняется монтирование LV к каталогам.LVM - Logical Volume Manager

LVM -плюсы:
 - Позволяет не думать о порядке томов
 - Имеет команды для увеличения размера ФС
 - Берет на себя вопрос физического хранения информации

LVM - минусы:
 - Более медленная работа с диском (по факту сильной потери производительности нет)
 - Не все ОС имеют драйвер для работы с LVM
 - В некоторых версиях GNU/Linux GRUB не может загрузиться с LVM

#

{{ PREFIX }{{ COMMAND }} [OPTIONS] [ARGUMENTS]

## Работа с PV:

; посмотреть список PV:
pvs

; посмотреть список PV с выводом подробной информации:
pvdisplay

; создать PV на устройстве:
pvcreate {{ DEVICE_PATH }}

## Работа с VG:

; посмотреть список VG:
vgs

; посмотреть список VG с выводом подробной информации:
vgdisplay

; создать VG и привязать к ней PV:
vgcreate {{ VG_NAME }} {{ PV_NAME }}

**  {{ PV_NAME }} = {{ DEVICE_PATH }}

## Работа с LV:

; посмотреть список LV:
lvs

; посмотреть список LV с выводом подробной информации:
lvdisplay

; создать LV с привязкой к VG, задав ему имя и размер:
lvcreate -L {{ SIZE }}{{ MEASURE }} -n {{ LV_NAME }} {{ VG_NAME }}
# Например:
lvcreate -L 1G -n test01 test

** файлы LV размещаются в каталоге /dev/mapper/ и именуются по формуле:
*** {{ VG_NAME }}{{ LV_NAME }}
*** обращаться к LV в командах bash нужно по имени файла.

; создать ФС на LV:
mkfs.{{ FS_NAME }} {{ LV_NAME }}

; монтировать LV к VFS:
mount {{ LV_NAME }} {{ MOUNT_PATH }}

-----
LSBLK

вывести список блочных устройств (можно посмотреть структуру разделов на дисках)

#

lsblk

#

--
DF

вывод отчета об использовании ФС (свободного места) дисков (разделов) в ОС:

#

df [OPTIONS]

; вывести объемы доступного, занятого и свободного пространства в человекочитаемом формате:
df -h

; добавить в вывод типы ФС:
df -T

#

--
DU

оценка использование файлового пространства

#

du [OPTIONS] {{ FILE_NAME }}

; определить в текущей директории занимаемое место всеми субдиректориями и файлами, размер в мегабайтах:
du -sm *

; определить в текущей директории занимаемое место всеми субдиректориями и файлами, размер в гигабайтах,
  выполниить сортировку вывода в порядке возрастания:
du -sB{{ MEASUREMENT }} * | sort -n

#

Планировщик ввода-вывода:
-------------------------

Если выполнять запросы на дисковый ввод-вывод от приложений в том порядке, в котором они
 поступают, производительность системы в среднем будет очень низкой. Это связано с тем, что
 операция поиска нужного сектора на жёстком диске – очень медленная. Поэтому планировщик
 обрабатывает очереди запросов, выполняя две операции:
 - сортировка: планировщик старается ставить подряд запросы, обращающиеся к находящимся
     близко секторам диска;

 - объединение: если в результате сортировки рядом оказались несколько запросов,
     обращающихся к последовательно расположенным секторам, их нужно объединить в один запрос.

В современном ядре доступно несколько планировщиков: Anticipatory, Deadline, CFQ, noop.
Существует версия ядра от Con Kolivas с ещё одним планировщиком — BFQ. Планировщики могут
 выбираться при компиляции ядра либо при его запуске.
Отметим планировщик noop: он не выполняет ни сортировку, ни слияние запросов, а перенаправляет
 запросы драйверам устройств в порядке поступления. На системах с обычными жёсткими дисками
 этот планировщик показал бы очень плохую производительность. Однако сейчас становятся
 распространены системы, в которых вместо жёстких дисков используются флэш-носители. Для таких
 носителей время поиска сектора равно нулю, поэтому операции сортировки и слияния не нужны. В
 таких системах при использовании планировщика noop производительность не меняется, а
 потребление ресурсов несколько снижается.

; Чтобы узнать, какие планировщики ввода-вывода доступны в вашей операционной системе Linux, можно воспользоваться командой:
cat /sys/block/sda/queue/scheduler

ПОЛЬЗОВАТЕЛИ И ГРУППЫ В ОС LINUX:
---------------------------------

Linux -  многопользовательская операционная система.
 Каждый процесс в пользовательском пространстве выполняется от имени того или иного пользователя.
 Поддержка прав на чтение/запись/выполнение поддерживается на уровне файловой системы,
  и позволяет гибко настраивать доступ к файлам отдельных пользователей и пользовательских групп.

ПОЛЬЗОВАТЕЛЬ - входит в систему, проходит процедуру авторизации и идентифицируется с какой-то учетной записью.
УЧЕТНАЯ ЗАПИСЬ - хранит информацию о пользователе, предназначенную для его опознания и предоставления
 доступа к его личным данным и настройкам.
ПРАВА ДОСТУПА - совокупность правил которые регламентирую порядок и условия доступа какого-то субъекта
(например пользователя) к объектам информационной системы (например файлам).
ГРУППА - именованная группа пользователей с одинаковыми правами доступа к тем или иным объектам ИС.
 Группы необходимы для организации нескольких пользователей к различным ресурсам.

Каждый пользователь имеет 2 основных атрибута:
 - UID (User identifier - идентификатор пользователя): ОС различает пользователей именно по UID!
   это число из диапазона 0 - 65535.
 - GID (Group identifier - идентификатор группы): Каждый пользователь в ОС принадлежит, как минимум, к 1 группе пользователей.
   При создании пользователя, по умолчанию создается группа для него. Как правило, имя группы пользователя по умолчанию
    совпадает с его именем. Пользователь может принадлежать к нескольким группам.

Условно можно разделить пользователей на 3 типа:
 - ROOT: суперпользователь (superuser): имеет неограниченные права в ОС.
   UID:GID = 0:0.
   Предназначен для работы с системными файлами, службами и всеми объектами, которые влияют на работу ОС;
 - SYSTEM USERS (Системные пользователи): нужны для обеспечения работы каких-то запущенных процессов/демонов.
   Как правило - не имеют оболочки, не могут авторизоваться в системе создаются автоматически при установке приложений;
 - USERS (простые пользователи): учетные записи, которые создаются администратором ОС для работы пользователей в этой ОС.
   могут быть локальными (создаваться на самом сервере), сетевыми (хранятся в домене LDAP - аналог AD).

В ОС Linux информация об учетных записях хранится в 3 файлах:
 - /etc/passwd: содержит общую информацию об УЗ:
   LOGIN:PASSWORD(метка его наличия или отсутсвия):UID:GID(основная):DESCRIPTION:HOME_DIRECTORY:SHELL
   SHELL для пользователей, как правило - /bin/bash,
    для системных пользователей: /usr/sbin/nologin или /bin/false - не позволит авторизоваться в консоли под этой учеткой!;
 - /etc/group: содержит общую информацию о группах пользователей:
   GROUP_NAME:PASSWORD(метка):GID:UID(перечисляются все пользователи, которые входят в группу);
 - /etc/shadow: хранит информацию о паролях УЗ:
   LOGIN:PASSWORD(hash или *):
    Для усложнения подбора пароля по хешу, функция hash использует соль (salt) - некий случайный набор символов, которой генерируется при создании хеша
    и дополняет хеш пароля.
    Первые 2 символа hash указывают на тип шифрования:
     - $1 = md5 = 22 символа;
     - $5 = sha-256 = 43 символа;
     - $6 = sha-512 = 86 символов.
    Следующие 16 символов - это соль.
    Далее следует сам hash.

    - число дней последнего изменения пароля, начиная с 1 января 1970 года:
    - число дней, перед тем как пароль может быть изменён:
    - число дней, после которых пароль должен быть изменён:
    - число дней, за сколько пользователя начнут предупреждать, что пароль устаревает:
    - число дней, после устаревания пароля для блокировки учётной записи:
    - число дней, отсчитывая с 1 января 1970 года, когда учётная запись будет заблокирована:
    - зарезервированное поле

   Для усложнения подбора пароля по хешу, функция hash использует соль (salt) - некое случайно генерируется при создании хеша
    и дополняет хеш пароля.
   Первые 2 символа hash указывают на тип шифрования:
    - $1 = md5 = 22 символа;
    - $5 = sha-256 = 43 символа;
    - $6 = sha-512 = 86 символов.
   Следующие 16 символов - это соль.
   Далее следует сам hash.

; Создание пользователя:
useradd {{ USER_NAME }}

# Создается пользователь с указанным именем, группа пользователя,
## ему назначается оболочка по умолчанию, пароль и домашняя директория не создаются:
    -s {{ SHELL_NAME }}   # задается оболочка для пользователя;
    -m                         # создать домашний каталог.
                               ## /etc/skel - содержит шаблон домашней директории;
    -b {{ HOME_DIRECTORY }}    # назначить домашний каталог (абсолютное имя домашнего каталога);
                               ## если такого каталога нет, для создания требует указать -m.

; Создать (задать)/изменить пароль пользователя:
passwd {{ USER_NAME }}

; Создание пользователя с помощью perl скрипта:
adduser {{ USER_NAME }}

# В процессе выполнения создает домашнюю директорию, группу, оболочку,  запрашивает пароль и дополнительную информацию.

; Удалить пользователя командой:
userdel {{ USER_NAME }}
# ключ -r удаляет, так же домашнюю дерикторию пользователя.

; Удалить пользователя с помощью perl скрипта:
deluser {{ USER_NAME }}

; Создать группу пользователей:
groupadd {{ GROUP_NAME }}

; Добавить пользователя в группу:
usermod -aG {{ GROUP_NAME }} {{ USER_NAME }}
# где:
    -a        # добавить;
    -G        # дополнительные группы.

; Удалить пользователя из группы с помощью perl скрипта:
deluser {{ USER_NAME }} {{ GROUP_NAME }}

; Удалить группу пользователей командой:
groupdel  {{ GROUP_NAME }}

; Удалить группу пользователей с помощью perl скрипта:
delgroup {{ GROUP_NAME }}
#

------
WHOAMI

Показать имя текущего пользователя

#
whoami

; подробный вывод
who am i
## или who

; самый подробный вывод:
w
#

--
ID

Показать к каким группам принадлежит пользователь (по умолчаню - текущий)

#
id {{ USER_NAME }}
#

------
GROUPS

Показывает группу по умолчанию для пользователя ( по умолчанию - текущего)

#
groups {{ USER_NAME }}
#

---
WHO

Показать активные сеансы пользователей

#
who

; более подробный вывод
w
#

----
LAST

Показать последние успешные сеансы пользователей

#
last

--------------------------------------------
ПЕРЕКЛЮЧЕНИЕ НА ДРУГОГО ПОЛЬЗОВАТЕЛЯ
ВЫПОЛНЕНИЕ ОПЕРАЦИЙ ОТ ДРУГОГО ПОЛЬЗОВАТЕЛЯ
ЗАВЕРШЕНИЕ ТЕКУЩЕЙ СЕССИИ ТЕКУЩЕГО ПОЛЬЗОВАТЕЛЯ:
--------------------------------------------
!!! Воспользоваться командой sudo могут только пользователи группы sudo.
  Эти пользователи перечислены в файле /etc/sudoers !!!
  Пользователи добавляются в этот файл с помощью утилит:
visudo
# или
sudoedit

; переключиться на пользователя root:
sudo -s
# или
sudo su

; Выполнять команды под UID и GID другого пользователя, текущая дериктория и env не меняются:
su {{ USER_NAME }}

; Выполнять команды под UID и GID другого пользователя, текущая дериктория и env меняются:
su - {{ USER_NAME }}

; Создать терминальную сессию под другим пользователем:
sudo - {{ USER_NAME }}

# Если команда выполняется из под root:
su - {{ USER_NAME }}

; Завершить текущую сессию текущего пользователя:
exit
# или
CTRL+D

; выполнить команду с привелигерованными правами
sudo {{ COMMAND_NAME }}

#

----------------------------------------------
ПРАВА ДОСТУПА К ФАЙЛАМ И КАТАЛОГАМ В ОС LINUX:
----------------------------------------------

В Linux - все есть файл.

 С каждым файлом связан индексный дескриптор (inode) - структура хранящая метаинформацию о файле:
   имена, размер, местоположение, владелец, группа, права доступа, даты и прочие атрибуты.
** Количество файлов не может превышать количества inode!!!
** Теоретически можно увеличить количество inode в системе, если увеличить дисковое пространство отведенное под ФС,
 
    при условии, что в параметрах ФС задан параметр "resize_inode", проверить можно командой:
sudo tune2fs -l {{ DEVICE_PATH/PARTITION }}

Права доступа к файлам обозначаются набором символов (10 шт.), который можно условно разделить на 4 группы:
tuuugggooo, где:
 - t: тип файла;
 - uuu: права для владельца файла;
 - ggg: права для группы владельца;
 - ooo: права для всех остальных (owner).

Типы файла могут обозначаться следующими символами:
 - "-": обычный файл;
 - d  : каталог;
 - b  : блочное устройство;
 - c  : символьное устройство;
 - l  : ссылка (soft link);
 - p  : именованный канал;
 - s  : сокет.

Каждая группа прав включает в себя три типа доступа к файлу - rwx:
 - чтение - read - (файла и содержимого каталога (требует x)): r = 100 = 4;
 - запись - write: w = 010 = 2;
 - выполнение - execute - (для запуска исполняемых файлов и доступа к каталогу): x = 001 = 1;
Отсутствие разрешения на какой-либо тип доступа обозначается знаком "-" или цифрой "0".
Складывая десятичные значения прав в группе можно обозначать их одной общей цифрой:
Например:
  ---: полное отсутсвие доступа = 000 = 0;
  r--: только чтение (файла) = 100 = 4;
  rw-: запись и чтение (файла) = 110 = 6;
  r-x: чтение содержимого файла и каталога, запуск исполняемого файла = 101 = 5;
  rwx: полный доступ к файлу и каталогу = 111 = 7.

В итоге, общий вид для обозначения прав на файл (каталог) для всех групп:
-rwxrwxrwx, или
drwxrwxrwx.

!!! При создании файла и каталога командами touch и mkdir,
 права назначаемые по умолчанию берутся из параметров, значение которых можно посмотреть командой umask.

-----
UMASK

Задает шаблон прав по умолчанию для создаваемых файлов и директорий.

Полный набор стандартных прав для:
файла = 666;
директории = 777.

Для расчета прав, задаваемых по умолчанию, для файла и дериктории, при их создании -
 из полного набора стандартных прав отнимается значение umask, например:

```
umask = 022,
Значит, для директории правами по умолчанию, при ее создании будут:
777 - 022 = 755 = rwx-r-xr-x;
а для файла:
666 - 022 = 644 = rw-r--r--.

-----------------------------
СПЕЦИАЛЬНЫЕ БИТЫ ПРАВ ДОСТУПА
SUID, SGUID, STICKY BIT:
-----------------------------
STICKY BIT - дополнительный атрибут, который устанавливается для каталогов -
  Только владелец файла может удалить в указанном каталоге свой файл.

; установить sticky bit
chmod +t {{ DIRECTORY_NAME }}
# или
chmod 1{{ UGO }} {{ DIRECTORY_NAME }}

; снять sticky bit
chmod +t {{ DIRECTORY_NAME }}
# или
chmod 0{{ UGO }} {{ DIRECTORY_NAME }}

------
CHMOD:

Change mode - Для назначения/смены прав на файл/каталог:

chmod {{ RIGHTS }} {{ FILE_or_DIR }};

Права можно указывать следующими способами:
XYZ, где:
- X: для кого модифицируются права = u, g или o - если не указывать кому = всем;
- Y: добавить/убрать/установить: +/-/=;
- Z: тип доступа = r, w, x - можно указывать несколько типов доступа сразу.

Например:
chmod a+rx FILE_NAME1        # добавить всем остальным права на чтение и запуск исполняемого файла с именем "FILE_NAME1".

Или цифровым обозначением прав для каждой группы, например:
chmod 754 FILE_NAME1        # что равно = -rwxr-xr--.

------
CHOWN:

Change owner - Смена владельца/группы владельца на файл/каталог:

; Сменить владельца файла/каталога:
chown {{ USER_NAME }} {{ FILE_or_DIR }}
#или:
chown {{ USER_NAME }}:{{ GROUP_NAME }} {{ FILE_or_DIR }}
      -R        # ключ добавляемый при смене владельца/группы каталога для рекурсивного назначения всему содержимому.

------
CHGRP:

Change grooup - Сменить группу владельца файла/каталога:
chgrp {{ USER_NAME }} {{ FILE_or_DIR }}

------
CHROOT

Change - root (directory) - Смена корневой (/) директории

#
chroot {{ ROOT_PATH }} {{ APP_PATH }}

--------------
ПРОЦЕССЫ, RAM:
--------------

Процесс - некоторая совокупность программного кода, который выполняется в памяти компьютера.

Бывают:
- Пользовательские - запущены пользователем;
- Системные - порождаются ядром ОС во время загрузки и выполняют системные функции.
   Выполняемые такими процессами программы - появляются не из исполняемого файла а являются частью ядра;
- Демоны - запускаются после инициализации ядра, работают в фоновом режиме и не привязаны к терминалу.
   Как правило имена процессов демонов заканчиваются на "d".

С точки зрения ядра - процесс представляет собой запись в таблице процессов.

Таблица процессов - специальная структура данных которая записывает все процессы запущенные в данный момент в ОС
 - их атрибуты, состояния строку команд.

Ctrl+C - Отменить ввод команды, прекратить выполнение текущего процесса
Ctrl+Z - отправить текущий процесс в background (фон)
fg - вернуть процесс из фона


---
LDD
Посмотреть какие библиотеки требуются приложению для его работы.

Например, если требуется перенести приложение в другую директорию для дальнейшего chroot.

#
ldd {{ APP_PATH }}

------
STRACE

Средство трассировки(распечатки) системных вызовов, полезно для выявления ошибок.

#
; Начать трассировку процесса, заданного идентификатором(PID):
strace -p {{ PID_NUMBER }}

; Трассировать процесс с фильтрацией выдач по определённому системному вызову:
strace -p {{ PID_NUMBER }} -e {{ SYSCALL_NAME }}

; Вывести при завершении программы таблицу, содержащую число обращений, ошибок и затраченное время по каждому из системных вызовов:
strace -p {{ PID_NUMBER }} -c

; Отображать при трассировке время, затраченное системным вызовом:
strace -p {{ PID_NUMBER }} -T

; Начать трассировку одновременно с выполнением программы:
strace {{ APP_NAME }}
#

------
LTRACE

Выводит список вызванных процессом функций из разделяемых библиотек

#
; Вывести трассировку вызовов библиотек при выполнении программы:
ltrace {{ APP_NAME }}

; Подсчитать количество вызовов библиотек, вывести итоговую таблицу при завершении процесса:
ltrace -c {{ APP_PATH }}

; Трассировать вызовы функций malloc и free, кроме тех, что были вызваны из библиотеки libc:
ltrace -e malloc+free-@libc.so* {{ APP_PATH }}

; Вывод в файл (не на терминал):
ltrace -o {{ FILE_NAME }} {{ APP_PATH }}
#

--
PS

Вывести моментальный снимок текущих процессов.
# по умолчанию выводит процессы текущей оболочки

#
ps [options]

; OPTIONS:
  a/e        # выбрать все процессы, кроме фоновых;
  u          # выбрать процессы пользователя;
  x          # ;
  f          # показывает полную информацию о процессах;
  F          # показывает еще больше информации о процессах;
  L,(H)      #отображать потоки процессов в колонках LWP и NLWP;
  --sort,(k) # выполнять сортировку по указанной колонке;
#

---
TOP

Интерактивный онлайновый диспетчер задач

#
top

; HOT_KEYS:
  [1]        # показывает нагрузку на каждый cpu отдельно, или отключает вывод о нагрузке cpu;
  [p]        # псевдографически отображает нарузку на процессор ввиде шкалы, или отключает вывод;
  [m]        # псевдографически отображает загрузку оперативной памяти ввиде шкалы, или отключает вывод;
  [CTRL+z]   # завершение top.
  [SHIFT+p]  # сортировать по %CPU
  [SHIFT+m]  # сортировать по%MEM
  [q]        # выход
#

----
FREE

Показать состояние памяти в байтах
 # отобраает значения для RAM и SWAP

#
free

; показать состояние памяти в MB, GB
free -h

; ПАРАМЕТРЫ ИНТЕРФЕЙСА:

 - total           # всего памяти;
 - used            # общая используемая память;
 - free            # сколько памяти "свободно" - не требуется, излишек;
 - shared          # сколько памяти используется совместно (общие библиотеки, процессы);
 - buff/cache      # сколько используется памяти для буфера и кеша;
 - available       # сколько памяти доступно.
#

-----
PKILL

Поиск, отправка сигналов или ожидание процессов на основе имени и других атрибутов

#
pkill [OPTIONS] {{ PATTERN }}

; Используйте команду kill -l для получения списка всех доступных сигналов.
; Наиболее часто используемые сигналы:
 - 1(HUP): перезагрузить процесс.
 - 9(KILL): убить процесс.
 - 15(TERM): изящно остановить процесс.

; Завершить (убить) конкретную сессию пользователя:
pkill -9 -t {{ TTY_NAME }}
#

------
DMESG:

Логи ядра (в RAM)

#
dmesg
#


--------
SHUTDOWN

Завершение работы хоста

#
; Немедленно завершить работу хоста:
shutdown now

-------------------------------------------
СЕТЬ, ИНФОРМАЦИЯ О СЕТИ, СЕТЕВЫЕ НАСТРОЙКИ:
-------------------------------------------

--------
IFCONFIG

Конфигурирование параметров сетевого интерфейса
# по умолчанию выводит параметры активных сетевых интерфейсов
# в Ubuntu содержится в составе пакета net-tools

#
ifconfig
# или
ip addr show
# или
ip a s

; показать маршруты по умолчанию:
ip route show
# или ip route или ip ro
# 

-----
ROUTE

Управление таблицами маршрутизации

#
route
#

-------
NETSTAT

выдать сетевые подключения компьютера

#
netstat
#

----
PING

Посылка пакетов ICMP ECHO_REQUEST сетевым хостам (по умолчанию бесконечна)

#
ping {{ IP_or_FQDN }}

; послать ограниченное количество запросов (COUNT)
ping -c {{ COUNT_OF_RESTS }}
#

----
HOST

Утилита поиска информации по IP из DNS

#
host {{ FQDN }}

; альтернатива - более подробный вывод
dig {{ FQDN }}
#

----------
TRACEROUTE

Вывести трассировку маршрутных пакетов до сетевого узла

#
traceroute {{ TARGET_HOST }}


Настройка сетевого интерфейса в Ubuntu:
---------------------------------------

Настройка сети в Ubuntu Server осуществляется через утилиту Netplan.

NetPlan — это инструмент для управления настройками сети,
 представленный в Ubuntu начиная с версии 17.10 и выше.

Этот инструмент заменяет файл статических интерфейсов /etc/network/interfaces,
 который ранее использовался для настройки сетевых интерфейсов в Ubuntu.
 Теперь нужно использовать /etc/netplan/*.yaml для ваших изменений в настройках сетевых интерфейсов.

; редактируем файл конфигурации netplan который находится в директории /etc/netplan/:
sudo vim /etc/netplan/00-installer-config.yaml
##!!! В РЕДАКТИРУЕМОМ ФАЙЛЕ СТРУКТУРУ ЗАДАЮТ ПРОБЕЛЫ А НЕ ТАБУЛЯЦИЯ!!!

# пример конфигурации с dhcp:

# пример конфигурации со статическим адресом:
...
network:
 ethernets:
  eth0:
   addresses:
    - {{ STATIC_IP }}/ {{ MASK }}
   routes:
    - to: default
      via: {{ DEFAULT_GATEWAY }}
   nameservers:
    addresses: [{{ DNS_SERVER_1 }}, {{ DNS_SERVER_... }}]
   optional: true
 version: 2
 renderer: networkd
...

; использование netplan для генерации необходимой конфигурации:
sudo netplan generate

; для подробного вывода информации при генерации, используйте опцию --debug:
sudo netplan --debug generate

; применение конфигурации netplan:
sudo netplan apply

; для подробного вывода информации при применении, используйте опцию --debug:
sudo netplan --debug apply

; далее рекомендуется перезапустить интерфейсы или перезагрузить сервер:
sudo reboot

# Если есть необходимость передать управление сетевыми устройствами утилите NetworkManager:
...
network:
 version: 2
 renderer: NetworkManager
...

-----------------------------------
ОТПРАВКА И ЗАГРУЗКА ДАННЫХ ПО СЕТИ:
-----------------------------------

----
WGET

Неинтерактивный загрузчик файлов по сети

#
wget - скачать файл из интернета
#
; скачать конкретный файл:
wget {{ FILE_WEB_LINK }}

----------------------------
УПРАВЛЕНИЕ ПАКЕТАМИ В LINUX:
----------------------------

--------------------------------------------------------------
УСТАНОВКА И УДАЛЕНИЕ ПАКЕТОВ ВСТРОЕННЫМИ ПАКЕТНЫМИ МЕНЕДЖЕРАМИ

# Ubuntu/Debian/Kali/Mint Linux:
!!! Пакеты имеют расширение ".deb"

; скачать и установить пакет из подключенного репозитория (программу)
apt-get install

; Посмотреть подключенные репозитории:
/etc/apt/sources. list

; удалить установленный пакет
apt-get remove

; установить программу из пакета
dpkg -i {{ PACKET_NAME }}

; удалить установленный пакет
dpkg -r {{ PACKET_NAME }}


# Red Hat/Centos Linux:
!!! Пакеты имеют расширение ".rpm"

; скачать и установить пакет из подключенного репозитория (программу)
yum install

; удалить установленный пакет
yum remove

; установить программу из пакета
rpm -i {{ PACKET_NAME }}

; удалить установленный пакет
rpm -e {{ PACKET_NAME }}


-----------------------------------------
НАСТРОЙКА СЕТЕВОГО ЭКРАНА - INUX FIREWALL
-----------------------------------------

#
; Открыть порт:
ufw allow {{ PORT_NUMBER }}
#

---------------------------------
SSH ПОДКЛЮЧЕНИЕ К УДАЛЕНЫМ ХОСТАМ
---------------------------------

SSH (Secure Shell) - это сетевой протокол,
 позволяющий пользователю получить доступ
 к удаленному серверу и осуществлять его управление.
Для подключения по умолчанию используется 22 порт.

; Проверить запущен ли демон sshd (Ubuntu):
ps ax | grep sshd

; Создать пару ssh ключей (приватный/публичный):
ssh-keygen

# Содержимое публичного ключа (id_rsa.pub) помещается на удаленный хост
## в директорию ~/.ssh целевого пользователя в файл authorized_keys.
; Это можно сделать командой (на локальном сервере):
ssh-copy-id {{ DST_USER }}@{{ DST_HOST }}


------------------
ШИФРОВАНИЕ ФАЙЛОВ:
------------------

--------
OPENSSL:

полноценная криптографическая библиотека с открытым исходным кодом, широко известна из-за расширения SSL/TLS, используемого в веб-протоколе HTTPS.

Поддерживает почти все низкоуровневые алгоритмы хеширования,
 шифрования и электронной подписи,
 а также реализует большинство популярных криптографических стандартов,
 в том числе позволяет создавать ключи RSA, DH, DSA, сертификаты X.509,
 подписывать их, формировать CSR (Certificate Signing Request) и CRT (файл сертификата безопасности),
 шифровать данные и тестировать SSL/TLS соединения.

; сгенерировать последовательность из 32 случайных символов
openssl rand -base64 32

; зашифровать файл методом aes-256-cbc
openssl enc -aes-256-cbc -in {{ SOURCE_FILE }} -out {{ DEST_FILE }}

; расшифровать файл методом aes-256-cbc
openssl enc -d -aes-256-cbc -in {{ SOURCE_FILE }} -out {{ DEST_FILE }}

-----------------------------
ГРАФИЧЕСКАЯ ПОДСИСТЕМА LINUX:
-----------------------------

----------------
X WINDOW SYSTEM:

; запуск X Window сервера:
startx


---------------------
ИНФОРМАЦИЯ О СИСТЕМЕ:
---------------------

; посмотреть время раьоты системы с момента последнего запуска:
uptime

; печать определенной системной информации (например версию ядра):
uname

; более подробный вывод о версии ядра:
uname -a

; еще один способ получить информацию о версии ядра:
cat /proc/version

; информация об установленной версии ОС:
cat /etc/*-release 

; вывести системную дату и время:
date

Просмотр сведений об оборудовании:
----------------------------------

----
LSHW

вывести информацию об оборудовании

#
lshw         # выведет список подключенного оборудования с краткими характеристиками (настройками)

; определите все доступные сетевые интерфейсы:
sudo lshw -class network

=================
ПОДЕЗНЫЕ УТИЛИТЫ:
=================
